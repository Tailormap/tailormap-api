<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SolrAdminController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Aggregate Test Coverage</a> &gt; <a href="index.source.html" class="el_package">org.tailormap.api.controller.admin</a> &gt; <span class="el_source">SolrAdminController.java</span></div><h1>SolrAdminController.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2024 B3Partners B.V.
 *
 * SPDX-License-Identifier: MIT
 */
package org.tailormap.api.controller.admin;

import com.fasterxml.jackson.databind.ObjectMapper;
import io.micrometer.core.annotation.Timed;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import java.io.IOException;
import java.lang.invoke.MethodHandles;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.UUID;
import org.apache.solr.client.solrj.SolrClient;
import org.apache.solr.client.solrj.SolrServerException;
import org.apache.solr.client.solrj.response.SolrPingResponse;
import org.apache.solr.common.SolrException;
import org.quartz.JobKey;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;
import org.tailormap.api.admin.model.SearchIndexSummary;
import org.tailormap.api.persistence.SearchIndex;
import org.tailormap.api.persistence.TMFeatureSource;
import org.tailormap.api.persistence.TMFeatureType;
import org.tailormap.api.repository.FeatureTypeRepository;
import org.tailormap.api.repository.SearchIndexRepository;
import org.tailormap.api.scheduling.IndexTask;
import org.tailormap.api.scheduling.TMJobDataMap;
import org.tailormap.api.scheduling.Task;
import org.tailormap.api.scheduling.TaskManagerService;
import org.tailormap.api.scheduling.TaskType;
import org.tailormap.api.solr.SolrHelper;
import org.tailormap.api.solr.SolrService;
import org.tailormap.api.viewer.model.ErrorResponse;

/** Admin controller for Solr. */
@RestController
public class SolrAdminController {
<span class="nc" id="L59">  private static final Logger logger =</span>
<span class="nc" id="L60">      LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());</span>

  private final FeatureTypeRepository featureTypeRepository;
  private final SearchIndexRepository searchIndexRepository;
  private final SolrService solrService;
  private final Scheduler scheduler;
  private final TaskManagerService taskManagerService;

  @Value(&quot;${tailormap-api.solr-query-timeout-seconds:7}&quot;)
  private int solrQueryTimeout;

  public SolrAdminController(
      @Autowired FeatureTypeRepository featureTypeRepository,
      @Autowired SearchIndexRepository searchIndexRepository,
      @Autowired SolrService solrService,
      @Autowired Scheduler scheduler,
<span class="nc" id="L76">      @Autowired TaskManagerService taskManagerService) {</span>
<span class="nc" id="L77">    this.featureTypeRepository = featureTypeRepository;</span>
<span class="nc" id="L78">    this.searchIndexRepository = searchIndexRepository;</span>
<span class="nc" id="L79">    this.solrService = solrService;</span>
<span class="nc" id="L80">    this.scheduler = scheduler;</span>
<span class="nc" id="L81">    this.taskManagerService = taskManagerService;</span>
<span class="nc" id="L82">  }</span>

  @ExceptionHandler({ResponseStatusException.class})
  public ResponseEntity&lt;?&gt; handleException(ResponseStatusException ex) {
    // wrap the exception in a proper json response
<span class="nc" id="L87">    return ResponseEntity.status(ex.getStatusCode())</span>
<span class="nc" id="L88">        .contentType(MediaType.APPLICATION_JSON)</span>
<span class="nc" id="L89">        .body(new ErrorResponse()</span>
<span class="nc" id="L90">            .message(</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">                ex.getReason() != null</span>
<span class="nc" id="L92">                    ? ex.getReason()</span>
<span class="nc" id="L93">                    : ex.getBody().getTitle())</span>
<span class="nc" id="L94">            .code(ex.getStatusCode().value()));</span>
  }

  /**
   * Ping solr.
   *
   * @return the response entity (ok or an error response)
   */
  @Operation(summary = &quot;Ping Solr&quot;, description = &quot;Ping Solr to check if it is available&quot;)
  @ApiResponse(
      responseCode = &quot;200&quot;,
      description = &quot;Solr is available&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema = @Schema(example = &quot;{\&quot;status\&quot;:\&quot;OK\&quot;,\&quot;timeElapsed\&quot;:1}&quot;)))
  @ApiResponse(
      responseCode = &quot;500&quot;,
      description = &quot;Solr is not available&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema = @Schema(example = &quot;{\&quot;message\&quot;:\&quot;Some error message..\&quot;,\&quot;code\&quot;:500}&quot;)))
  @GetMapping(path = &quot;${tailormap-api.admin.base-path}/index/ping&quot;, produces = MediaType.APPLICATION_JSON_VALUE)
  public ResponseEntity&lt;?&gt; pingSolr() {
<span class="nc" id="L119">    try (SolrClient solrClient = solrService.getSolrClientForSearching()) {</span>
<span class="nc" id="L120">      final SolrPingResponse ping = solrClient.ping();</span>
<span class="nc" id="L121">      logger.info(&quot;Solr ping status {}&quot;, ping.getResponse().get(&quot;status&quot;));</span>
<span class="nc" id="L122">      return ResponseEntity.ok(new ObjectMapper()</span>
<span class="nc" id="L123">          .createObjectNode()</span>
<span class="nc" id="L124">          .put(&quot;status&quot;, ping.getResponse().get(&quot;status&quot;).toString())</span>
<span class="nc" id="L125">          .put(&quot;timeElapsed&quot;, ping.getElapsedTime()));</span>
<span class="nc" id="L126">    } catch (IOException | SolrServerException e) {</span>
<span class="nc" id="L127">      logger.error(&quot;Error pinging solr&quot;, e);</span>
<span class="nc" id="L128">      throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, e.getMessage());</span>
    }
  }

  /**
   * (re-) Index a layer.
   *
   * @param searchIndexId the searchIndex id
   * @return the response entity (accepted or an error response)
   */
  @Operation(
      summary = &quot;Create or update a feature type index&quot;,
      description = &quot;Create or update a feature type index for a layer, will erase existing index if present&quot;)
  @ApiResponse(
      responseCode = &quot;202&quot;,
      description = &quot;Index create or update request accepted&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema =
                  @Schema(
                      example =
                          &quot;{\&quot;type\&quot;:\&quot;index\&quot;, \&quot;uuid\&quot;:\&quot;6308d26e-fe1e-4268-bb28-20db2cd06914\&quot;,\&quot;code\&quot;:202}&quot;)))
  @ApiResponse(
      responseCode = &quot;404&quot;,
      description = &quot;Layer does not have feature type&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema =
                  @Schema(
                      example =
                          &quot;{\&quot;message\&quot;:\&quot;Layer does not have feature type\&quot;,\&quot;code\&quot;:404}&quot;)))
  @ApiResponse(
      responseCode = &quot;400&quot;,
      description = &quot;Indexing WFS feature types is not supported&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema =
                  @Schema(
                      example =
                          &quot;{\&quot;message\&quot;:\&quot;Layer does not have valid feature type for indexing\&quot;,\&quot;code\&quot;:400}&quot;)))
  @ApiResponse(
      responseCode = &quot;500&quot;,
      description = &quot;Error while indexing&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema = @Schema(example = &quot;{\&quot;message\&quot;:\&quot;Some error message..\&quot;,\&quot;code\&quot;:500}&quot;)))
  @Transactional
  @Timed(value = &quot;index_feature_type&quot;, description = &quot;time spent to index feature type&quot;)
  @PutMapping(
      path = &quot;${tailormap-api.admin.base-path}/index/{searchIndexId}&quot;,
      produces = MediaType.APPLICATION_JSON_VALUE)
  public ResponseEntity&lt;?&gt; index(@PathVariable Long searchIndexId) {
<span class="nc" id="L184">    SearchIndex searchIndex = validateInputAndFindIndex(searchIndexId);</span>

<span class="nc bnc" id="L186" title="All 2 branches missed.">    if (searchIndex.getStatus() == SearchIndex.Status.INDEXING) {</span>
<span class="nc" id="L187">      throw new ResponseStatusException(</span>
          HttpStatus.CONFLICT, &quot;Indexing already in progress, check tasks overview before retrying&quot;);
    }

<span class="nc" id="L191">    boolean createNewIndex =</span>
<span class="nc bnc" id="L192" title="All 4 branches missed.">        (null == searchIndex.getLastIndexed() || searchIndex.getStatus() == SearchIndex.Status.INITIAL);</span>

<span class="nc bnc" id="L194" title="All 2 branches missed.">    boolean hasSchedule = (null != searchIndex.getSchedule()</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">        &amp;&amp; null != searchIndex.getSchedule().getUuid());</span>

    UUID taskUuid;
    try {
<span class="nc bnc" id="L199" title="All 2 branches missed.">      if (hasSchedule) {</span>
<span class="nc" id="L200">        taskUuid = searchIndex.getSchedule().getUuid();</span>
<span class="nc" id="L201">        startScheduledJobIndexing(searchIndex);</span>
      } else {
<span class="nc" id="L203">        taskUuid = startOneTimeJobIndexing(searchIndex);</span>
      }
<span class="nc" id="L205">      searchIndexRepository.save(searchIndex);</span>
<span class="nc" id="L206">    } catch (UnsupportedOperationException</span>
        | IOException
        | SolrServerException
        | SolrException
        | SchedulerException e) {
<span class="nc" id="L211">      logger.error(&quot;Error indexing&quot;, e);</span>
<span class="nc" id="L212">      searchIndex.setStatus(SearchIndex.Status.ERROR);</span>
<span class="nc" id="L213">      searchIndexRepository.save(searchIndex);</span>
<span class="nc" id="L214">      throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, e.getMessage());</span>
<span class="nc" id="L215">    }</span>

<span class="nc" id="L217">    logger.info(</span>
        &quot;Scheduled {} index for search index {}&quot;,
<span class="nc bnc" id="L219" title="All 2 branches missed.">        (createNewIndex ? &quot;creation of a new&quot; : &quot;update of&quot;),</span>
<span class="nc" id="L220">        searchIndex.getName());</span>
<span class="nc" id="L221">    return ResponseEntity.accepted()</span>
<span class="nc" id="L222">        .body(Map.of(</span>
            &quot;code&quot;,
<span class="nc" id="L224">            202,</span>
            Task.TYPE_KEY,
<span class="nc" id="L226">            TaskType.INDEX.getValue(),</span>
            Task.UUID_KEY,
            taskUuid,
            &quot;message&quot;,
            &quot;Indexing scheduled&quot;));
  }

  private UUID startOneTimeJobIndexing(SearchIndex searchIndex)
      throws SolrServerException, IOException, SchedulerException {
<span class="nc" id="L235">    UUID taskName = taskManagerService.createTask(</span>
        IndexTask.class,
<span class="nc" id="L237">        new TMJobDataMap(Map.of(</span>
            Task.TYPE_KEY,
            TaskType.INDEX,
            Task.DESCRIPTION_KEY,
<span class="nc" id="L241">            &quot;One-time indexing of &quot; + searchIndex.getName(),</span>
            IndexTask.INDEX_KEY,
<span class="nc" id="L243">            searchIndex.getId().toString(),</span>
            Task.PRIORITY_KEY,
<span class="nc" id="L245">            0)));</span>
<span class="nc" id="L246">    logger.info(&quot;One-time indexing job with UUID {} started&quot;, taskName);</span>
<span class="nc" id="L247">    return taskName;</span>
  }

  private void startScheduledJobIndexing(SearchIndex searchIndex) throws SchedulerException {
<span class="nc" id="L251">    JobKey jobKey = taskManagerService.getJobKey(</span>
<span class="nc" id="L252">        TaskType.INDEX, searchIndex.getSchedule().getUuid());</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">    if (null == jobKey) {</span>
<span class="nc" id="L254">      throw new SchedulerException(&quot;Indexing job not found in scheduler&quot;);</span>
    }
<span class="nc" id="L256">    scheduler.triggerJob(jobKey);</span>
<span class="nc" id="L257">    logger.info(</span>
        &quot;Indexing of scheduled job with UUID {} started&quot;,
<span class="nc" id="L259">        searchIndex.getSchedule().getUuid());</span>
<span class="nc" id="L260">  }</span>

  /**
   * Validate input and find the search index.
   *
   * @param searchIndexId the search index id
   * @return the search index
   * @throws ResponseStatusException if the search index is not found or the feature type is not found
   */
  private SearchIndex validateInputAndFindIndex(Long searchIndexId) {
    // check if solr is available
<span class="nc" id="L271">    this.pingSolr();</span>

    // check if search index exists
<span class="nc" id="L274">    SearchIndex searchIndex = searchIndexRepository</span>
<span class="nc" id="L275">        .findById(searchIndexId)</span>
<span class="nc" id="L276">        .orElseThrow(() -&gt; new ResponseStatusException(HttpStatus.NOT_FOUND, &quot;Search index not found&quot;));</span>

    // check if feature type exists
<span class="nc" id="L279">    TMFeatureType indexingFT = featureTypeRepository</span>
<span class="nc" id="L280">        .findById(searchIndex.getFeatureTypeId())</span>
<span class="nc" id="L281">        .orElseThrow(() -&gt; new ResponseStatusException(HttpStatus.NOT_FOUND, &quot;Feature type not found&quot;));</span>

<span class="nc bnc" id="L283" title="All 2 branches missed.">    if (TMFeatureSource.Protocol.WFS.equals(indexingFT.getFeatureSource().getProtocol())) {</span>
      // the search index should not exist for WFS feature types, but test just in case
<span class="nc" id="L285">      searchIndex</span>
<span class="nc" id="L286">          .setStatus(SearchIndex.Status.ERROR)</span>
<span class="nc" id="L287">          .setSummary(new SearchIndexSummary().errorMessage(&quot;WFS indexing not supported&quot;));</span>
<span class="nc" id="L288">      throw new ResponseStatusException(</span>
          HttpStatus.BAD_REQUEST, &quot;Layer does not have valid feature type for indexing&quot;);
    }
<span class="nc" id="L291">    return searchIndex;</span>
  }

  /**
   * Clear an index; does not remove the {@link SearchIndex} metadata.
   *
   * @param searchIndexId the searchindex id
   * @return the response entity ({@code 204 NOCONTENT} or an error response)
   */
  @Operation(summary = &quot;Clear index for a feature type&quot;, description = &quot;Clear index for the feature type&quot;)
  @ApiResponse(responseCode = &quot;204&quot;, description = &quot;Index cleared&quot;)
  @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Index not configured for feature type&quot;)
  @ApiResponse(
      responseCode = &quot;500&quot;,
      description = &quot;Error while clearing index&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema = @Schema(example = &quot;{\&quot;message\&quot;:\&quot;Some error message..\&quot;,\&quot;code\&quot;:500}&quot;)))
  @Timed(value = &quot;index_delete&quot;, description = &quot;time spent to delete an index of a feature type&quot;)
  @DeleteMapping(
      path = &quot;${tailormap-api.admin.base-path}/index/{searchIndexId}&quot;,
      produces = MediaType.APPLICATION_JSON_VALUE)
  @Transactional
  public ResponseEntity&lt;?&gt; clearIndex(@PathVariable Long searchIndexId) {
<span class="nc" id="L316">    try (SolrClient solrClient = solrService.getSolrClientForSearching();</span>
<span class="nc" id="L317">        SolrHelper solrHelper = new SolrHelper(solrClient).withQueryTimeout(solrQueryTimeout)) {</span>
<span class="nc" id="L318">      solrHelper.clearIndexForLayer(searchIndexId);</span>
      // do not delete the SearchIndex metadata object
      // searchIndexRepository.findById(searchIndexId).ifPresent(searchIndexRepository::delete);
<span class="nc" id="L321">      SearchIndex searchIndex = searchIndexRepository</span>
<span class="nc" id="L322">          .findById(searchIndexId)</span>
<span class="nc" id="L323">          .orElseThrow(() -&gt; new ResponseStatusException(HttpStatus.NOT_FOUND, &quot;Search index not found&quot;));</span>
<span class="nc" id="L324">      searchIndex</span>
<span class="nc" id="L325">          .setLastIndexed(null)</span>
<span class="nc" id="L326">          .setStatus(SearchIndex.Status.INITIAL)</span>
<span class="nc" id="L327">          .setSummary(new SearchIndexSummary().total(0));</span>
<span class="nc" id="L328">      searchIndexRepository.save(searchIndex);</span>
<span class="nc" id="L329">    } catch (IOException | SolrServerException | NoSuchElementException e) {</span>
<span class="nc" id="L330">      logger.warn(&quot;Error clearing index&quot;, e);</span>
<span class="nc" id="L331">      throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, e.getMessage());</span>
<span class="nc" id="L332">    }</span>

<span class="nc" id="L334">    logger.info(&quot;Index cleared for index {}&quot;, searchIndexId);</span>
<span class="nc" id="L335">    return ResponseEntity.noContent().build();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>