<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TaskAdminController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Tailormap API</a> &gt; <a href="index.source.html" class="el_package">org.tailormap.api.controller.admin</a> &gt; <span class="el_source">TaskAdminController.java</span></div><h1>TaskAdminController.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2024 B3Partners B.V.
 *
 * SPDX-License-Identifier: MIT
 */
package org.tailormap.api.controller.admin;

import static java.net.HttpURLConnection.HTTP_ACCEPTED;
import static java.net.HttpURLConnection.HTTP_BAD_REQUEST;
import static java.net.HttpURLConnection.HTTP_NOT_FOUND;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import java.lang.invoke.MethodHandles;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.UUID;
import org.quartz.CronTrigger;
import org.quartz.InterruptableJob;
import org.quartz.JobDataMap;
import org.quartz.JobDetail;
import org.quartz.JobKey;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.Trigger;
import org.quartz.TriggerKey;
import org.quartz.TriggerUtils;
import org.quartz.impl.matchers.GroupMatcher;
import org.quartz.spi.OperableTrigger;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;
import org.tailormap.api.scheduling.Task;
import org.tailormap.api.scheduling.TaskManagerService;
import org.tailormap.api.scheduling.TaskType;

/**
 * Admin controller for controlling the task scheduler. Not to be used to create new tasks, adding
 * tasks belongs in the domain of the specific controller or Spring Data REST API as that requires
 * specific configuration information.
 */
@RestController
public class TaskAdminController {
<span class="nc" id="L60">  private static final Logger logger =</span>
<span class="nc" id="L61">      LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());</span>

  private final Scheduler scheduler;
  private final TaskManagerService taskManagerService;

  public TaskAdminController(
<span class="nc" id="L67">      @Autowired Scheduler scheduler, @Autowired TaskManagerService taskManagerService) {</span>
<span class="nc" id="L68">    this.scheduler = scheduler;</span>
<span class="nc" id="L69">    this.taskManagerService = taskManagerService;</span>
<span class="nc" id="L70">  }</span>

  @Operation(
      summary = &quot;List all tasks, optionally filtered by type&quot;,
      description =
          &quot;&quot;&quot;
          This will return a list of all tasks, optionally filtered by task type.
          The state of the task is one of the Quartz Trigger states.
          The state can be one of: NONE, NORMAL, PAUSED, COMPLETE, ERROR, BLOCKED or null in error conditions.
          &quot;&quot;&quot;)
  @GetMapping(
      path = &quot;${tailormap-api.admin.base-path}/tasks&quot;,
      produces = MediaType.APPLICATION_JSON_VALUE)
  @ApiResponse(
      responseCode = &quot;200&quot;,
      description = &quot;List of all tasks, this list may be empty&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema =
                  @Schema(
                      example =
                          &quot;&quot;&quot;
                          {&quot;tasks&quot;:[
                          {&quot;uuid&quot;:&quot;6308d26e-fe1e-4268-bb28-20db2cd06914&quot;,&quot;type&quot;:&quot;index&quot;, &quot;state&quot;:&quot;NORMAL&quot;, &quot;interruptable&quot;: false},
                          {&quot;uuid&quot;:&quot;d5ce9152-e90e-4b5a-b129-3b2366cabca8&quot;,&quot;type&quot;:&quot;poc&quot;, &quot;state&quot;: &quot;BLOCKED&quot;, &quot;interruptable&quot;: false},
                          {&quot;uuid&quot;:&quot;d5ce9152-e90e-4b5a-b129-3b2366cabca9&quot;,&quot;type&quot;:&quot;poc&quot;, &quot;state&quot;: &quot;PAUSED&quot;, &quot;interruptable&quot;: false},
                          {&quot;uuid&quot;:&quot;d5ce9152-e90e-4b5a-b129-3b2366cabca2&quot;,&quot;type&quot;:&quot;poc&quot;, &quot;state&quot;: &quot;COMPLETE&quot;, &quot;interruptable&quot;: false},
                          {&quot;uuid&quot;:&quot;d5ce9152-e90e-4b5a-b129-3b2366cabca3&quot;,&quot;type&quot;:&quot;interuptablepoc&quot;, &quot;state&quot;: &quot;ERROR&quot;, &quot;interruptable&quot;: true}
                          ]}
                          &quot;&quot;&quot;)))
  public ResponseEntity&lt;Object&gt; list(@RequestParam(required = false) String type)
      throws ResponseStatusException {
<span class="nc bnc" id="L103" title="All 2 branches missed.">    logger.debug(&quot;Listing all tasks (optional type filter: {})&quot;, (null == type ? &quot;all&quot; : type));</span>
<span class="nc" id="L104">    final List&lt;ObjectNode&gt; tasks = new ArrayList&lt;&gt;();</span>

    final GroupMatcher&lt;JobKey&gt; groupMatcher =
<span class="nc bnc" id="L107" title="All 2 branches missed.">        (null == type ? GroupMatcher.anyGroup() : GroupMatcher.groupEquals(type));</span>
    try {
<span class="nc" id="L109">      scheduler.getJobKeys(groupMatcher).stream()</span>
<span class="nc" id="L110">          .map(</span>
              jobKey -&gt; {
                try {
<span class="nc" id="L113">                  return scheduler.getJobDetail(jobKey);</span>
<span class="nc" id="L114">                } catch (SchedulerException e) {</span>
<span class="nc" id="L115">                  logger.error(&quot;Error getting task detail&quot;, e);</span>
<span class="nc" id="L116">                  return null;</span>
                }
              })
<span class="nc" id="L119">          .filter(Objects::nonNull)</span>
<span class="nc" id="L120">          .forEach(</span>
              jobDetail -&gt; {
                Trigger.TriggerState state;
                try {
<span class="nc" id="L124">                  state =</span>
<span class="nc" id="L125">                      scheduler.getTriggerState(</span>
<span class="nc" id="L126">                          TriggerKey.triggerKey(</span>
<span class="nc" id="L127">                              jobDetail.getKey().getName(), jobDetail.getKey().getGroup()));</span>
<span class="nc" id="L128">                } catch (SchedulerException e) {</span>
<span class="nc" id="L129">                  logger.error(&quot;Error getting task state&quot;, e);</span>
                  // ignore; to get a null (unknown) state
<span class="nc" id="L131">                  state = null;</span>
<span class="nc" id="L132">                }</span>
<span class="nc" id="L133">                tasks.add(</span>
                    new ObjectMapper()
<span class="nc" id="L135">                        .createObjectNode()</span>
<span class="nc" id="L136">                        .put(Task.UUID_KEY, jobDetail.getKey().getName())</span>
<span class="nc" id="L137">                        .put(Task.TYPE_KEY, jobDetail.getKey().getGroup())</span>
<span class="nc" id="L138">                        .put(</span>
                            Task.INTERRUPTABLE_KEY,
<span class="nc" id="L140">                            InterruptableJob.class.isAssignableFrom(jobDetail.getJobClass()))</span>
<span class="nc" id="L141">                        .put(</span>
                            Task.DESCRIPTION_KEY,
<span class="nc" id="L143">                            jobDetail.getJobDataMap().getString(Task.DESCRIPTION_KEY))</span>
<span class="nc" id="L144">                        .put(</span>
                            Task.LAST_RESULT_KEY,
<span class="nc" id="L146">                            jobDetail.getJobDataMap().getString(Task.LAST_RESULT_KEY))</span>
<span class="nc" id="L147">                        .putPOJO(Task.STATE_KEY, state));</span>
<span class="nc" id="L148">              });</span>
<span class="nc" id="L149">    } catch (SchedulerException e) {</span>
<span class="nc" id="L150">      throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, &quot;Error getting tasks&quot;, e);</span>
<span class="nc" id="L151">    }</span>

<span class="nc" id="L153">    return ResponseEntity.ok(</span>
        new ObjectMapper()
<span class="nc" id="L155">            .createObjectNode()</span>
<span class="nc" id="L156">            .set(&quot;tasks&quot;, new ObjectMapper().createArrayNode().addAll(tasks)));</span>
  }

  @Operation(
      summary = &quot;List all details for a given task&quot;,
      description =
          &quot;&quot;&quot;
          This will return the details of the task, including the status, progress,
          result and any other information.
          &quot;&quot;&quot;)
  @GetMapping(
      path = &quot;${tailormap-api.admin.base-path}/tasks/{type}/{uuid}&quot;,
      produces = MediaType.APPLICATION_JSON_VALUE)
  @ApiResponse(
      responseCode = &quot;404&quot;,
      description = &quot;Task not found&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema = @Schema(example = &quot;{\&quot;message\&quot;:\&quot;Task not found\&quot;,\&quot;code\&quot;:404}&quot;)))
  @ApiResponse(
      responseCode = &quot;200&quot;,
      description = &quot;Details of the task&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema =
                  @Schema(
                      example =
                          &quot;&quot;&quot;
                          {
                            &quot;uuid&quot;:&quot;6308d26e-fe1e-4268-bb28-20db2cd06914&quot;,
                            &quot;type&quot;:&quot;poc&quot;,
                            &quot;interruptable&quot;:false,
                            &quot;description&quot;:&quot;This is a poc task&quot;,
                            &quot;startTime&quot;:&quot;2024-06-06T12:00:00Z&quot;,
                            &quot;nextTime&quot;:&quot;2024-06-06T12:00:00Z&quot;,
                            &quot;jobData&quot;:{
                              &quot;type&quot;:&quot;poc&quot;,
                              &quot;description&quot;:&quot;This is a poc task&quot;
                            },
                            &quot;state&quot;:&quot;NORMAL&quot;,
                            &quot;progress&quot;:&quot;...&quot;,
                            &quot;result&quot;:&quot;...&quot;,
                            &quot;message&quot;:&quot;something is happening&quot;
                          }
                          &quot;&quot;&quot;)))
  public ResponseEntity&lt;Object&gt; details(@PathVariable TaskType type, @PathVariable UUID uuid)
      throws ResponseStatusException {
<span class="nc" id="L205">    logger.debug(&quot;Getting task details for {}:{}&quot;, type, uuid);</span>

    try {
<span class="nc" id="L208">      JobKey jobKey = taskManagerService.getJobKey(type, uuid);</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">      if (null == jobKey) {</span>
<span class="nc" id="L210">        return handleTaskNotFound();</span>
      }

<span class="nc" id="L213">      JobDetail jobDetail = scheduler.getJobDetail(jobKey);</span>
<span class="nc" id="L214">      JobDataMap jobDataMap = jobDetail.getJobDataMap();</span>

      /* there should be only one */
<span class="nc" id="L217">      Trigger trigger = scheduler.getTriggersOfJob(jobDetail.getKey()).get(0);</span>
<span class="nc" id="L218">      CronTrigger cron = ((CronTrigger) trigger);</span>

<span class="nc" id="L220">      final Object[] result = new Object[1];</span>
<span class="nc" id="L221">      scheduler.getCurrentlyExecutingJobs().stream()</span>
<span class="nc" id="L222">          .filter(Objects::nonNull)</span>
<span class="nc" id="L223">          .forEach(</span>
              jobExecutionContext -&gt; {
<span class="nc" id="L225">                logger.debug(</span>
                    &quot;currently executing job {} with trigger {}.&quot;,
<span class="nc" id="L227">                    jobExecutionContext.getJobDetail().getKey(),</span>
<span class="nc" id="L228">                    jobExecutionContext.getTrigger().getKey());</span>

<span class="nc" id="L230">                result[0] = jobExecutionContext.getResult();</span>
<span class="nc" id="L231">              });</span>

<span class="nc" id="L233">      return ResponseEntity.ok(</span>
          new ObjectMapper()
<span class="nc" id="L235">              .createObjectNode()</span>
              // immutable uuid, type and description
<span class="nc" id="L237">              .put(Task.UUID_KEY, jobDetail.getKey().getName())</span>
<span class="nc" id="L238">              .put(Task.TYPE_KEY, jobDetail.getKey().getGroup())</span>
<span class="nc" id="L239">              .put(</span>
                  Task.INTERRUPTABLE_KEY,
<span class="nc" id="L241">                  InterruptableJob.class.isAssignableFrom(jobDetail.getJobClass()))</span>
<span class="nc" id="L242">              .put(Task.DESCRIPTION_KEY, jobDataMap.getString(Task.DESCRIPTION_KEY))</span>
<span class="nc" id="L243">              .put(Task.CRON_EXPRESSION_KEY, cron.getCronExpression())</span>
              // TODO / XXX we could add a human-readable description of the cron expression using
              // eg.
              //   com.cronutils:cron-utils like:
              //     CronParser cronParser = new
              //         CronParser(CronDefinitionBuilder.instanceDefinitionFor(QUARTZ));
              //     CronDescriptor.instance(locale).describe(cronParser.parse(cronExpression));
              //   this could also be done front-end using eg.
              // https://www.npmjs.com/package/cronstrue
              //   which has the advantage of knowing the required locale for the human
              // .put(&quot;cronDescription&quot;, cron.getCronExpression())
<span class="nc" id="L254">              .put(&quot;timezone&quot;, cron.getTimeZone().getID())</span>
<span class="nc" id="L255">              .putPOJO(&quot;startTime&quot;, trigger.getStartTime())</span>
<span class="nc" id="L256">              .putPOJO(&quot;lastTime&quot;, trigger.getPreviousFireTime())</span>
<span class="nc" id="L257">              .putPOJO(</span>
<span class="nc" id="L258">                  &quot;nextFireTimes&quot;, TriggerUtils.computeFireTimes((OperableTrigger) cron, null, 5))</span>
<span class="nc" id="L259">              .putPOJO(Task.STATE_KEY, scheduler.getTriggerState(trigger.getKey()))</span>
<span class="nc" id="L260">              .putPOJO(&quot;progress&quot;, result[0])</span>
<span class="nc" id="L261">              .put(Task.LAST_RESULT_KEY, jobDataMap.getString(Task.LAST_RESULT_KEY))</span>
<span class="nc" id="L262">              .putPOJO(&quot;jobData&quot;, jobDataMap));</span>
<span class="nc" id="L263">    } catch (SchedulerException e) {</span>
<span class="nc" id="L264">      throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, &quot;Error getting task&quot;, e);</span>
    }
  }

  @Operation(
      summary = &quot;Start a task&quot;,
      description = &quot;This will start the task if it is not already running&quot;)
  @PutMapping(
      path = &quot;${tailormap-api.admin.base-path}/tasks/{type}/{uuid}/start&quot;,
      produces = MediaType.APPLICATION_JSON_VALUE)
  @ApiResponse(
      responseCode = &quot;404&quot;,
      description = &quot;Task not found&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema = @Schema(example = &quot;{\&quot;message\&quot;:\&quot;Task not found\&quot;,\&quot;code\&quot;:404}&quot;)))
  @ApiResponse(
      responseCode = &quot;202&quot;,
      description = &quot;Task is started&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema = @Schema(example = &quot;{\&quot;message\&quot;:\&quot;Task starting accepted\&quot;,\&quot;code\&quot;:202}&quot;)))
  public ResponseEntity&lt;Object&gt; startTask(@PathVariable TaskType type, @PathVariable UUID uuid)
      throws ResponseStatusException {
<span class="nc" id="L290">    logger.debug(&quot;Starting task {}:{}&quot;, type, uuid);</span>

    try {
<span class="nc" id="L293">      JobKey jobKey = taskManagerService.getJobKey(type, uuid);</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">      if (null == jobKey) {</span>
<span class="nc" id="L295">        return handleTaskNotFound();</span>
      }
<span class="nc" id="L297">      scheduler.triggerJob(jobKey);</span>
<span class="nc" id="L298">      return ResponseEntity.status(HttpStatusCode.valueOf(HTTP_ACCEPTED))</span>
<span class="nc" id="L299">          .body(new ObjectMapper().createObjectNode().put(&quot;message&quot;, &quot;Task starting accepted&quot;));</span>

<span class="nc" id="L301">    } catch (SchedulerException e) {</span>
<span class="nc" id="L302">      throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, &quot;Error getting task&quot;, e);</span>
    }
  }

  @Operation(
      summary = &quot;Stop a task irrevocably&quot;,
      description =
          &quot;&quot;&quot;
              This will stop a running task, if the task is not running, nothing will happen.
              This can leave the application in an inconsistent state.
              A task that is not interruptable cannot be stopped.
              A stopped task cannot be restarted, it fire again depending on the schedule.
              &quot;&quot;&quot;)
  @PutMapping(
      path = &quot;${tailormap-api.admin.base-path}/tasks/{type}/{uuid}/stop&quot;,
      produces = MediaType.APPLICATION_JSON_VALUE)
  @ApiResponse(
      responseCode = &quot;404&quot;,
      description = &quot;Task not found&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema = @Schema(example = &quot;{\&quot;message\&quot;:\&quot;Task not found\&quot;, \&quot;code\&quot;:404}&quot;)))
  @ApiResponse(
      responseCode = &quot;202&quot;,
      description = &quot;Task is stopping&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema =
                  @Schema(
                      example =
                          &quot;&quot;&quot;
                                {
                                &quot;message&quot;:&quot;Task stopping accepted&quot;.
                                &quot;succes&quot;:true
                                }
                              &quot;&quot;&quot;)))
  @ApiResponse(
      responseCode = &quot;400&quot;,
      description =
          &quot;The task cannot be stopped as it does not implement the InterruptableJob interface.&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema =
                  @Schema(
                      example =
                          &quot;&quot;&quot;
                                        {
                                        &quot;message&quot;:&quot;Task cannot be stopped&quot;
                                        }
                                      &quot;&quot;&quot;)))
  public ResponseEntity&lt;Object&gt; stopTask(@PathVariable TaskType type, @PathVariable UUID uuid)
      throws ResponseStatusException {
<span class="nc" id="L357">    logger.debug(&quot;Stopping task {}:{}&quot;, type, uuid);</span>

    try {
<span class="nc" id="L360">      JobKey jobKey = taskManagerService.getJobKey(type, uuid);</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">      if (null == jobKey) {</span>
<span class="nc" id="L362">        return handleTaskNotFound();</span>
      }

<span class="nc bnc" id="L365" title="All 2 branches missed.">      if (InterruptableJob.class.isAssignableFrom(scheduler.getJobDetail(jobKey).getJobClass())) {</span>
<span class="nc" id="L366">        boolean interrupted = scheduler.interrupt(jobKey);</span>
<span class="nc" id="L367">        return ResponseEntity.status(HttpStatusCode.valueOf(HTTP_ACCEPTED))</span>
<span class="nc" id="L368">            .body(</span>
                new ObjectMapper()
<span class="nc" id="L370">                    .createObjectNode()</span>
<span class="nc" id="L371">                    .put(&quot;message&quot;, &quot;Task stopping accepted&quot;)</span>
<span class="nc" id="L372">                    .put(&quot;succes&quot;, interrupted));</span>
      } else {
<span class="nc" id="L374">        return ResponseEntity.status(HttpStatusCode.valueOf(HTTP_BAD_REQUEST))</span>
<span class="nc" id="L375">            .body(</span>
                new ObjectMapper()
<span class="nc" id="L377">                    .createObjectNode()</span>
<span class="nc" id="L378">                    .put(&quot;message&quot;, &quot;Task cannot be stopped&quot;)</span>
<span class="nc" id="L379">                    .put(&quot;succes&quot;, false));</span>
      }

<span class="nc" id="L382">    } catch (SchedulerException e) {</span>
<span class="nc" id="L383">      throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, &quot;Error getting task&quot;, e);</span>
    }
  }

  @Operation(
      summary = &quot;Delete a task&quot;,
      description =
          &quot;This will remove the task from the scheduler and delete all information about the task&quot;)
  @DeleteMapping(
      path = &quot;${tailormap-api.admin.base-path}/tasks/{type}/{uuid}&quot;,
      produces = MediaType.APPLICATION_JSON_VALUE)
  @ApiResponse(
      responseCode = &quot;404&quot;,
      description = &quot;Task not found&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema = @Schema(example = &quot;{\&quot;message\&quot;:\&quot;Task not found\&quot;}&quot;)))
  @ApiResponse(responseCode = &quot;204&quot;, description = &quot;Task is deleted&quot;)
  public ResponseEntity&lt;Object&gt; delete(@PathVariable TaskType type, @PathVariable UUID uuid)
      throws ResponseStatusException {

    try {
<span class="nc" id="L406">      JobKey jobKey = taskManagerService.getJobKey(type, uuid);</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">      if (null == jobKey) {</span>
<span class="nc" id="L408">        return handleTaskNotFound();</span>
      }

<span class="nc" id="L411">      boolean succes = scheduler.deleteJob(jobKey);</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">      logger.info(&quot;Task {}:{} deletion {}&quot;, type, uuid, (succes ? &quot;succeeded&quot; : &quot;failed&quot;));</span>

<span class="nc" id="L414">      return ResponseEntity.noContent().build();</span>
<span class="nc" id="L415">    } catch (SchedulerException e) {</span>
<span class="nc" id="L416">      throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, &quot;Error getting task&quot;, e);</span>
    }
  }

  private ResponseEntity&lt;Object&gt; handleTaskNotFound() {
<span class="nc" id="L421">    return ResponseEntity.status(HttpStatusCode.valueOf(HTTP_NOT_FOUND))</span>
<span class="nc" id="L422">        .contentType(MediaType.APPLICATION_JSON)</span>
<span class="nc" id="L423">        .body(</span>
            new ObjectMapper()
<span class="nc" id="L425">                .createObjectNode()</span>
<span class="nc" id="L426">                .put(&quot;message&quot;, &quot;Task not found&quot;)</span>
<span class="nc" id="L427">                .put(&quot;code&quot;, HTTP_NOT_FOUND));</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>