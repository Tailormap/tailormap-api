<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TaskAdminController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Tailormap API</a> &gt; <a href="index.source.html" class="el_package">org.tailormap.api.controller.admin</a> &gt; <span class="el_source">TaskAdminController.java</span></div><h1>TaskAdminController.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2024 B3Partners B.V.
 *
 * SPDX-License-Identifier: MIT
 */
package org.tailormap.api.controller.admin;

import static java.net.HttpURLConnection.HTTP_ACCEPTED;
import static java.net.HttpURLConnection.HTTP_BAD_REQUEST;
import static java.net.HttpURLConnection.HTTP_NOT_FOUND;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import java.lang.invoke.MethodHandles;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.UUID;
import org.quartz.CronTrigger;
import org.quartz.InterruptableJob;
import org.quartz.JobDataMap;
import org.quartz.JobDetail;
import org.quartz.JobKey;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.Trigger;
import org.quartz.TriggerKey;
import org.quartz.TriggerUtils;
import org.quartz.impl.matchers.GroupMatcher;
import org.quartz.spi.OperableTrigger;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;
import org.tailormap.api.repository.SearchIndexRepository;
import org.tailormap.api.scheduling.Task;
import org.tailormap.api.scheduling.TaskManagerService;
import org.tailormap.api.scheduling.TaskType;

/**
 * Admin controller for controlling the task scheduler. Not to be used to create new tasks, adding tasks belongs in the
 * domain of the specific controller or Spring Data REST API as that requires specific configuration information.
 * Provides the following endpoints:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #list /admin/tasks} to list all tasks, optionally filtered by type
 *   &lt;li&gt;{@link #details /admin/tasks/{type}/{uuid}} to get the details of a task
 *   &lt;li&gt;{@link #startTask /admin/tasks/{type}/{uuid}/start} to start a task
 *   &lt;li&gt;{@link #stopTask /admin/tasks/{type}/{uuid}/stop} to stop a task
 *   &lt;li&gt;{@link #delete /admin/tasks/{type}/{uuid}} to delete a task
 * &lt;/ul&gt;
 */
@RestController
public class TaskAdminController {
<span class="nc" id="L69">  private static final Logger logger =</span>
<span class="nc" id="L70">      LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());</span>

  private final Scheduler scheduler;
  private final TaskManagerService taskManagerService;
  private final SearchIndexRepository searchIndexRepository;

  public TaskAdminController(
      @Autowired Scheduler scheduler,
      @Autowired TaskManagerService taskManagerService,
<span class="nc" id="L79">      @Autowired SearchIndexRepository searchIndexRepository) {</span>
<span class="nc" id="L80">    this.scheduler = scheduler;</span>
<span class="nc" id="L81">    this.taskManagerService = taskManagerService;</span>
<span class="nc" id="L82">    this.searchIndexRepository = searchIndexRepository;</span>
<span class="nc" id="L83">  }</span>

  @Operation(
      summary = &quot;List all tasks, optionally filtered by type&quot;,
      description =
          &quot;&quot;&quot;
This will return a list of all tasks, optionally filtered by task type.
The state of the task is one of the Quartz Trigger states.
The state can be one of: NONE, NORMAL, PAUSED, COMPLETE, ERROR, BLOCKED or null in error conditions.
&quot;&quot;&quot;)
  @GetMapping(path = &quot;${tailormap-api.admin.base-path}/tasks&quot;, produces = MediaType.APPLICATION_JSON_VALUE)
  @ApiResponse(
      responseCode = &quot;200&quot;,
      description = &quot;List of all tasks, this list may be empty&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema =
                  @Schema(
                      example =
                          &quot;&quot;&quot;
{&quot;tasks&quot;:[
{&quot;uuid&quot;:&quot;6308d26e-fe1e-4268-bb28-20db2cd06914&quot;,&quot;type&quot;:&quot;index&quot;, &quot;state&quot;:&quot;NORMAL&quot;, &quot;interruptable&quot;: false},
{&quot;uuid&quot;:&quot;d5ce9152-e90e-4b5a-b129-3b2366cabca8&quot;,&quot;type&quot;:&quot;poc&quot;, &quot;state&quot;: &quot;BLOCKED&quot;, &quot;interruptable&quot;: false},
{&quot;uuid&quot;:&quot;d5ce9152-e90e-4b5a-b129-3b2366cabca9&quot;,&quot;type&quot;:&quot;poc&quot;, &quot;state&quot;: &quot;PAUSED&quot;, &quot;interruptable&quot;: false},
{&quot;uuid&quot;:&quot;d5ce9152-e90e-4b5a-b129-3b2366cabca2&quot;,&quot;type&quot;:&quot;poc&quot;, &quot;state&quot;: &quot;COMPLETE&quot;, &quot;interruptable&quot;: false},
{&quot;uuid&quot;:&quot;d5ce9152-e90e-4b5a-b129-3b2366cabca3&quot;,&quot;type&quot;:&quot;interuptablepoc&quot;, &quot;state&quot;: &quot;ERROR&quot;, &quot;interruptable&quot;: true}
]}
&quot;&quot;&quot;)))
  public ResponseEntity&lt;Object&gt; list(@RequestParam(required = false) String type) throws ResponseStatusException {
<span class="nc bnc" id="L113" title="All 2 branches missed.">    logger.debug(&quot;Listing all tasks (optional type filter: {})&quot;, (null == type ? &quot;all&quot; : type));</span>
<span class="nc" id="L114">    final List&lt;ObjectNode&gt; tasks = new ArrayList&lt;&gt;();</span>

    final GroupMatcher&lt;JobKey&gt; groupMatcher =
<span class="nc bnc" id="L117" title="All 2 branches missed.">        (null == type ? GroupMatcher.anyGroup() : GroupMatcher.groupEquals(type));</span>
    try {
<span class="nc" id="L119">      scheduler.getJobKeys(groupMatcher).stream()</span>
<span class="nc" id="L120">          .map(jobKey -&gt; {</span>
            try {
<span class="nc" id="L122">              return scheduler.getJobDetail(jobKey);</span>
<span class="nc" id="L123">            } catch (SchedulerException e) {</span>
<span class="nc" id="L124">              logger.error(&quot;Error getting task detail&quot;, e);</span>
<span class="nc" id="L125">              return null;</span>
            }
          })
<span class="nc" id="L128">          .filter(Objects::nonNull)</span>
<span class="nc" id="L129">          .forEach(jobDetail -&gt; {</span>
            Trigger.TriggerState state;
            try {
<span class="nc" id="L132">              state = scheduler.getTriggerState(TriggerKey.triggerKey(</span>
<span class="nc" id="L133">                  jobDetail.getKey().getName(),</span>
<span class="nc" id="L134">                  jobDetail.getKey().getGroup()));</span>
<span class="nc" id="L135">            } catch (SchedulerException e) {</span>
<span class="nc" id="L136">              logger.error(&quot;Error getting task state&quot;, e);</span>
<span class="nc" id="L137">              state = null;</span>
<span class="nc" id="L138">            }</span>
<span class="nc" id="L139">            tasks.add(new ObjectMapper()</span>
<span class="nc" id="L140">                .createObjectNode()</span>
<span class="nc" id="L141">                .put(Task.TYPE_KEY, jobDetail.getKey().getGroup())</span>
<span class="nc" id="L142">                .put(Task.UUID_KEY, jobDetail.getKey().getName())</span>
<span class="nc" id="L143">                .put(</span>
                    Task.INTERRUPTABLE_KEY,
<span class="nc" id="L145">                    InterruptableJob.class.isAssignableFrom(jobDetail.getJobClass()))</span>
<span class="nc" id="L146">                .put(</span>
                    Task.DESCRIPTION_KEY,
<span class="nc" id="L148">                    jobDetail.getJobDataMap().getString(Task.DESCRIPTION_KEY))</span>
<span class="nc" id="L149">                .put(</span>
                    Task.LAST_RESULT_KEY,
<span class="nc" id="L151">                    jobDetail.getJobDataMap().getString(Task.LAST_RESULT_KEY))</span>
<span class="nc" id="L152">                .putPOJO(Task.STATE_KEY, state));</span>
<span class="nc" id="L153">          });</span>
<span class="nc" id="L154">    } catch (SchedulerException e) {</span>
<span class="nc" id="L155">      throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, &quot;Error getting tasks&quot;, e);</span>
<span class="nc" id="L156">    }</span>

<span class="nc" id="L158">    return ResponseEntity.ok(new ObjectMapper()</span>
<span class="nc" id="L159">        .createObjectNode()</span>
<span class="nc" id="L160">        .set(&quot;tasks&quot;, new ObjectMapper().createArrayNode().addAll(tasks)));</span>
  }

  @Operation(
      summary = &quot;List all details for a given task&quot;,
      description =
          &quot;&quot;&quot;
This will return the details of the task, including the status, progress,
result and any other information.
&quot;&quot;&quot;)
  @GetMapping(
      path = &quot;${tailormap-api.admin.base-path}/tasks/{type}/{uuid}&quot;,
      produces = MediaType.APPLICATION_JSON_VALUE)
  @ApiResponse(
      responseCode = &quot;404&quot;,
      description = &quot;Task not found&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema = @Schema(example = &quot;{\&quot;message\&quot;:\&quot;Task not found\&quot;,\&quot;code\&quot;:404}&quot;)))
  @ApiResponse(
      responseCode = &quot;200&quot;,
      description =
          &quot;&quot;&quot;
Details of the task. The response content will vay according to the type of task,
the most common fields are listed in the Task interface.
&quot;&quot;&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema =
                  @Schema(
                      example =
                          &quot;&quot;&quot;
{
&quot;type&quot;:&quot;poc&quot;,
&quot;uuid&quot;:&quot;6308d26e-fe1e-4268-bb28-20db2cd06914&quot;,
&quot;interruptable&quot;:false,
&quot;description&quot;:&quot;This is a poc task&quot;,
&quot;startTime&quot;:&quot;2024-06-06T12:00:00Z&quot;,
&quot;nextTime&quot;:&quot;2024-06-06T12:00:00Z&quot;,
&quot;state&quot;:&quot;NORMAL&quot;,
&quot;progress&quot;:&quot;...&quot;,
&quot;result&quot;:&quot;...&quot;,
&quot;message&quot;:&quot;something is happening&quot;
&quot;jobData&quot;:{ &quot;type&quot;:&quot;poc&quot;, &quot;description&quot;:&quot;This is a poc task&quot; }
}
&quot;&quot;&quot;)))
  public ResponseEntity&lt;Object&gt; details(@PathVariable TaskType type, @PathVariable UUID uuid)
      throws ResponseStatusException {
<span class="nc" id="L210">    logger.debug(&quot;Getting task details for {}:{}&quot;, type, uuid);</span>

    try {
<span class="nc" id="L213">      JobKey jobKey = taskManagerService.getJobKey(type, uuid);</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">      if (null == jobKey) {</span>
<span class="nc" id="L215">        return handleTaskNotFound();</span>
      }

<span class="nc" id="L218">      JobDetail jobDetail = scheduler.getJobDetail(jobKey);</span>
<span class="nc" id="L219">      JobDataMap jobDataMap = jobDetail.getJobDataMap();</span>

      /* there should be only one */
<span class="nc" id="L222">      Trigger trigger = scheduler.getTriggersOfJob(jobDetail.getKey()).get(0);</span>
<span class="nc" id="L223">      CronTrigger cron = ((CronTrigger) trigger);</span>

<span class="nc" id="L225">      final Object[] result = new Object[1];</span>
<span class="nc" id="L226">      scheduler.getCurrentlyExecutingJobs().stream()</span>
<span class="nc" id="L227">          .filter(Objects::nonNull)</span>
<span class="nc" id="L228">          .filter(jobExecutionContext -&gt;</span>
<span class="nc" id="L229">              jobExecutionContext.getJobDetail().getKey().equals(jobKey))</span>
<span class="nc" id="L230">          .forEach(jobExecutionContext -&gt; {</span>
<span class="nc" id="L231">            logger.debug(</span>
                &quot;currently executing job {} with trigger {}.&quot;,
<span class="nc" id="L233">                jobExecutionContext.getJobDetail().getKey(),</span>
<span class="nc" id="L234">                jobExecutionContext.getTrigger().getKey());</span>

<span class="nc" id="L236">            result[0] = jobExecutionContext.getResult();</span>
<span class="nc" id="L237">          });</span>

<span class="nc" id="L239">      return ResponseEntity.ok(new ObjectMapper()</span>
<span class="nc" id="L240">          .createObjectNode()</span>
          // immutable uuid, type and description
<span class="nc" id="L242">          .put(Task.TYPE_KEY, jobDetail.getKey().getGroup())</span>
<span class="nc" id="L243">          .put(Task.UUID_KEY, jobDetail.getKey().getName())</span>
<span class="nc" id="L244">          .put(Task.INTERRUPTABLE_KEY, InterruptableJob.class.isAssignableFrom(jobDetail.getJobClass()))</span>
<span class="nc" id="L245">          .put(Task.DESCRIPTION_KEY, jobDataMap.getString(Task.DESCRIPTION_KEY))</span>
<span class="nc" id="L246">          .put(Task.CRON_EXPRESSION_KEY, cron.getCronExpression())</span>
          // TODO / XXX we could add a human-readable description of the cron expression using
          // eg.
          //   com.cronutils:cron-utils like:
          //     CronParser cronParser = new
          //         CronParser(CronDefinitionBuilder.instanceDefinitionFor(QUARTZ));
          //     CronDescriptor.instance(locale).describe(cronParser.parse(cronExpression));
          //   this could also be done front-end using eg.
          // https://www.npmjs.com/package/cronstrue
          //   which has the advantage of knowing the required locale for the human
          // .put(&quot;cronDescription&quot;, cron.getCronExpression())
<span class="nc" id="L257">          .put(&quot;timezone&quot;, cron.getTimeZone().getID())</span>
<span class="nc" id="L258">          .putPOJO(&quot;startTime&quot;, trigger.getStartTime())</span>
<span class="nc" id="L259">          .putPOJO(&quot;lastTime&quot;, trigger.getPreviousFireTime())</span>
<span class="nc" id="L260">          .putPOJO(&quot;nextFireTimes&quot;, TriggerUtils.computeFireTimes((OperableTrigger) cron, null, 5))</span>
<span class="nc" id="L261">          .putPOJO(Task.STATE_KEY, scheduler.getTriggerState(trigger.getKey()))</span>
<span class="nc" id="L262">          .putPOJO(&quot;progress&quot;, result[0])</span>
<span class="nc" id="L263">          .put(Task.LAST_RESULT_KEY, jobDataMap.getString(Task.LAST_RESULT_KEY))</span>
<span class="nc" id="L264">          .putPOJO(&quot;jobData&quot;, jobDataMap));</span>
<span class="nc" id="L265">    } catch (SchedulerException e) {</span>
<span class="nc" id="L266">      throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, &quot;Error getting task&quot;, e);</span>
    }
  }

  @Operation(summary = &quot;Start a task&quot;, description = &quot;This will start the task if it is not already running&quot;)
  @PutMapping(
      path = &quot;${tailormap-api.admin.base-path}/tasks/{type}/{uuid}/start&quot;,
      produces = MediaType.APPLICATION_JSON_VALUE)
  @ApiResponse(
      responseCode = &quot;404&quot;,
      description = &quot;Task not found&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema = @Schema(example = &quot;{\&quot;message\&quot;:\&quot;Task not found\&quot;,\&quot;code\&quot;:404}&quot;)))
  @ApiResponse(
      responseCode = &quot;202&quot;,
      description = &quot;Task is started&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema = @Schema(example = &quot;{\&quot;message\&quot;:\&quot;Task starting accepted\&quot;,\&quot;code\&quot;:202}&quot;)))
  public ResponseEntity&lt;Object&gt; startTask(@PathVariable TaskType type, @PathVariable UUID uuid)
      throws ResponseStatusException {
<span class="nc" id="L290">    logger.debug(&quot;Starting task {}:{}&quot;, type, uuid);</span>

    try {
<span class="nc" id="L293">      JobKey jobKey = taskManagerService.getJobKey(type, uuid);</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">      if (null == jobKey) {</span>
<span class="nc" id="L295">        return handleTaskNotFound();</span>
      }
<span class="nc" id="L297">      scheduler.triggerJob(jobKey);</span>
<span class="nc" id="L298">      return ResponseEntity.status(HttpStatusCode.valueOf(HTTP_ACCEPTED))</span>
<span class="nc" id="L299">          .body(new ObjectMapper().createObjectNode().put(&quot;message&quot;, &quot;Task starting accepted&quot;));</span>

<span class="nc" id="L301">    } catch (SchedulerException e) {</span>
<span class="nc" id="L302">      throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, &quot;Error getting task&quot;, e);</span>
    }
  }

  @Operation(
      summary = &quot;Stop a task irrevocably&quot;,
      description =
          &quot;&quot;&quot;
This will stop a running task, if the task is not running, nothing will happen.
This can leave the application in an inconsistent state.
A task that is not interruptable cannot be stopped.
A stopped task cannot be restarted, it fire again depending on the schedule.
&quot;&quot;&quot;)
  @PutMapping(
      path = &quot;${tailormap-api.admin.base-path}/tasks/{type}/{uuid}/stop&quot;,
      produces = MediaType.APPLICATION_JSON_VALUE)
  @ApiResponse(
      responseCode = &quot;404&quot;,
      description = &quot;Task not found&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema = @Schema(example = &quot;{\&quot;message\&quot;:\&quot;Task not found\&quot;, \&quot;code\&quot;:404}&quot;)))
  @ApiResponse(
      responseCode = &quot;202&quot;,
      description = &quot;Task is stopping&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema = @Schema(example = &quot;&quot;&quot;
{
&quot;message&quot;:&quot;Task stopping accepted&quot;.
&quot;succes&quot;:true
}
&quot;&quot;&quot;)))
  @ApiResponse(
      responseCode = &quot;400&quot;,
      description = &quot;The task cannot be stopped as it does not implement the InterruptableJob interface.&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema = @Schema(example = &quot;&quot;&quot;
{ &quot;message&quot;:&quot;Task cannot be stopped&quot; }
&quot;&quot;&quot;)))
  public ResponseEntity&lt;Object&gt; stopTask(@PathVariable TaskType type, @PathVariable UUID uuid)
      throws ResponseStatusException {
<span class="nc" id="L348">    logger.debug(&quot;Stopping task {}:{}&quot;, type, uuid);</span>

    try {
<span class="nc" id="L351">      JobKey jobKey = taskManagerService.getJobKey(type, uuid);</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">      if (null == jobKey) {</span>
<span class="nc" id="L353">        return handleTaskNotFound();</span>
      }

<span class="nc bnc" id="L356" title="All 2 branches missed.">      if (InterruptableJob.class.isAssignableFrom(</span>
<span class="nc" id="L357">          scheduler.getJobDetail(jobKey).getJobClass())) {</span>
<span class="nc" id="L358">        boolean interrupted = scheduler.interrupt(jobKey);</span>
<span class="nc" id="L359">        return ResponseEntity.status(HttpStatusCode.valueOf(HTTP_ACCEPTED))</span>
<span class="nc" id="L360">            .body(new ObjectMapper()</span>
<span class="nc" id="L361">                .createObjectNode()</span>
<span class="nc" id="L362">                .put(&quot;message&quot;, &quot;Task stopping accepted&quot;)</span>
<span class="nc" id="L363">                .put(&quot;succes&quot;, interrupted));</span>
      } else {
<span class="nc" id="L365">        return ResponseEntity.status(HttpStatusCode.valueOf(HTTP_BAD_REQUEST))</span>
<span class="nc" id="L366">            .body(new ObjectMapper()</span>
<span class="nc" id="L367">                .createObjectNode()</span>
<span class="nc" id="L368">                .put(&quot;message&quot;, &quot;Task cannot be stopped&quot;)</span>
<span class="nc" id="L369">                .put(&quot;succes&quot;, false));</span>
      }

<span class="nc" id="L372">    } catch (SchedulerException e) {</span>
<span class="nc" id="L373">      throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, &quot;Error getting task&quot;, e);</span>
    }
  }

  @Operation(
      summary = &quot;Delete a task&quot;,
      description = &quot;This will remove the task from the scheduler and delete all information about the task&quot;)
  @DeleteMapping(
      path = &quot;${tailormap-api.admin.base-path}/tasks/{type}/{uuid}&quot;,
      produces = MediaType.APPLICATION_JSON_VALUE)
  @ApiResponse(
      responseCode = &quot;404&quot;,
      description = &quot;Task not found&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema = @Schema(example = &quot;{\&quot;message\&quot;:\&quot;Task not found\&quot;}&quot;)))
  @ApiResponse(responseCode = &quot;204&quot;, description = &quot;Task is deleted&quot;)
  public ResponseEntity&lt;Object&gt; delete(@PathVariable TaskType type, @PathVariable UUID uuid)
      throws ResponseStatusException {

    try {
<span class="nc" id="L395">      JobKey jobKey = taskManagerService.getJobKey(type, uuid);</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">      if (null == jobKey) {</span>
<span class="nc" id="L397">        return handleTaskNotFound();</span>
      }

<span class="nc" id="L400">      boolean succes = scheduler.deleteJob(jobKey);</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">      logger.info(&quot;Task {}:{} deletion {}&quot;, type, uuid, (succes ? &quot;succeeded&quot; : &quot;failed&quot;));</span>
      // cleanup the schedule from the business objects
<span class="nc bnc" id="L403" title="All 2 branches missed.">      switch (type) {</span>
        case INDEX:
<span class="nc" id="L405">          deleteScheduleFromSearchIndex(uuid);</span>
<span class="nc" id="L406">          break;</span>
        case PROMETHEUS_PING:
        // no action required, as these are not managed in Tailormap
        default:
          break;
      }
<span class="nc" id="L412">      return ResponseEntity.noContent().build();</span>
<span class="nc" id="L413">    } catch (SchedulerException e) {</span>
<span class="nc" id="L414">      throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, &quot;Error getting task&quot;, e);</span>
    }
  }

  private void deleteScheduleFromSearchIndex(UUID uuid) {
<span class="nc" id="L419">    searchIndexRepository.findByTaskScheduleUuid(uuid).forEach(searchIndex -&gt; {</span>
<span class="nc" id="L420">      searchIndex.setSchedule(null);</span>
<span class="nc" id="L421">      searchIndexRepository.save(searchIndex);</span>
<span class="nc" id="L422">    });</span>
<span class="nc" id="L423">  }</span>

  private ResponseEntity&lt;Object&gt; handleTaskNotFound() {
<span class="nc" id="L426">    return ResponseEntity.status(HttpStatusCode.valueOf(HTTP_NOT_FOUND))</span>
<span class="nc" id="L427">        .contentType(MediaType.APPLICATION_JSON)</span>
<span class="nc" id="L428">        .body(new ObjectMapper()</span>
<span class="nc" id="L429">            .createObjectNode()</span>
<span class="nc" id="L430">            .put(&quot;message&quot;, &quot;Task not found&quot;)</span>
<span class="nc" id="L431">            .put(&quot;code&quot;, HTTP_NOT_FOUND));</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>