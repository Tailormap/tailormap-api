<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SolrAdminController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Tailormap API</a> &gt; <a href="index.source.html" class="el_package">org.tailormap.api.controller.admin</a> &gt; <span class="el_source">SolrAdminController.java</span></div><h1>SolrAdminController.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2024 B3Partners B.V.
 *
 * SPDX-License-Identifier: MIT
 */
package org.tailormap.api.controller.admin;

import com.fasterxml.jackson.databind.ObjectMapper;
import io.micrometer.core.annotation.Timed;
import io.micrometer.core.instrument.Metrics;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import java.io.IOException;
import java.lang.invoke.MethodHandles;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.UUID;
import java.util.concurrent.TimeUnit;
import org.apache.solr.client.solrj.SolrClient;
import org.apache.solr.client.solrj.SolrServerException;
import org.apache.solr.client.solrj.response.SolrPingResponse;
import org.apache.solr.common.SolrException;
import org.quartz.JobKey;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;
import org.tailormap.api.admin.model.SearchIndexSummary;
import org.tailormap.api.persistence.SearchIndex;
import org.tailormap.api.persistence.TMFeatureSource;
import org.tailormap.api.persistence.TMFeatureType;
import org.tailormap.api.repository.FeatureTypeRepository;
import org.tailormap.api.repository.SearchIndexRepository;
import org.tailormap.api.scheduling.IndexTask;
import org.tailormap.api.scheduling.SolrPingTask;
import org.tailormap.api.scheduling.TMJobDataMap;
import org.tailormap.api.scheduling.Task;
import org.tailormap.api.scheduling.TaskManagerService;
import org.tailormap.api.scheduling.TaskType;
import org.tailormap.api.solr.SolrHelper;
import org.tailormap.api.solr.SolrService;
import org.tailormap.api.viewer.model.ErrorResponse;

/** Admin controller for Solr. */
@RestController
public class SolrAdminController implements InitializingBean {
<span class="nc" id="L63">  private static final Logger logger =</span>
<span class="nc" id="L64">      LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());</span>

  private final FeatureTypeRepository featureTypeRepository;
  private final SearchIndexRepository searchIndexRepository;
  private final SolrService solrService;
  private final Scheduler scheduler;
  private final TaskManagerService taskManagerService;

  @Value(&quot;${tailormap-api.solr-query-timeout-seconds:7}&quot;)
  private int solrQueryTimeout;

  @Value(&quot;${tailormap-api.solr-api-ping-cron:0 0/5 * 1/1 * ? *}&quot;)
  private String solrPingCron;

  public SolrAdminController(
      @Autowired FeatureTypeRepository featureTypeRepository,
      @Autowired SearchIndexRepository searchIndexRepository,
      @Autowired SolrService solrService,
      @Autowired Scheduler scheduler,
<span class="nc" id="L83">      @Autowired TaskManagerService taskManagerService) {</span>
<span class="nc" id="L84">    this.featureTypeRepository = featureTypeRepository;</span>
<span class="nc" id="L85">    this.searchIndexRepository = searchIndexRepository;</span>
<span class="nc" id="L86">    this.solrService = solrService;</span>
<span class="nc" id="L87">    this.scheduler = scheduler;</span>
<span class="nc" id="L88">    this.taskManagerService = taskManagerService;</span>
<span class="nc" id="L89">  }</span>

  @ExceptionHandler({ResponseStatusException.class})
  public ResponseEntity&lt;?&gt; handleException(ResponseStatusException ex) {
    // wrap the exception in a proper json response
<span class="nc" id="L94">    return ResponseEntity.status(ex.getStatusCode())</span>
<span class="nc" id="L95">        .contentType(MediaType.APPLICATION_JSON)</span>
<span class="nc" id="L96">        .body(new ErrorResponse()</span>
<span class="nc" id="L97">            .message(</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">                ex.getReason() != null</span>
<span class="nc" id="L99">                    ? ex.getReason()</span>
<span class="nc" id="L100">                    : ex.getBody().getTitle())</span>
<span class="nc" id="L101">            .code(ex.getStatusCode().value()));</span>
  }

  /**
   * Ping solr.
   *
   * @return the response entity (ok or an error response)
   */
  @Operation(summary = &quot;Ping Solr&quot;, description = &quot;Ping Solr to check if it is available&quot;)
  @ApiResponse(
      responseCode = &quot;200&quot;,
      description = &quot;Solr is available&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema = @Schema(example = &quot;{\&quot;status\&quot;:\&quot;OK\&quot;,\&quot;timeElapsed\&quot;:1}&quot;)))
  @ApiResponse(
      responseCode = &quot;500&quot;,
      description = &quot;Solr is not available&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema = @Schema(example = &quot;{\&quot;message\&quot;:\&quot;Some error message..\&quot;,\&quot;code\&quot;:500}&quot;)))
  @GetMapping(path = &quot;${tailormap-api.admin.base-path}/index/ping&quot;, produces = MediaType.APPLICATION_JSON_VALUE)
  public ResponseEntity&lt;?&gt; pingSolr() {
<span class="nc" id="L126">    try (SolrClient solrClient = solrService.getSolrClientForSearching()) {</span>
<span class="nc" id="L127">      final SolrPingResponse ping = solrClient.ping();</span>
<span class="nc" id="L128">      logger.info(&quot;Solr ping status {}&quot;, ping.getResponse().get(&quot;status&quot;));</span>
<span class="nc" id="L129">      Metrics.timer(&quot;tailormap_solr_ping&quot;).record(ping.getElapsedTime(), TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L130">      return ResponseEntity.ok(new ObjectMapper()</span>
<span class="nc" id="L131">          .createObjectNode()</span>
<span class="nc" id="L132">          .put(&quot;status&quot;, ping.getResponse().get(&quot;status&quot;).toString())</span>
<span class="nc" id="L133">          .put(&quot;timeElapsed&quot;, ping.getElapsedTime()));</span>
<span class="nc" id="L134">    } catch (IOException | SolrServerException e) {</span>
<span class="nc" id="L135">      logger.error(&quot;Error pinging solr&quot;, e);</span>
<span class="nc" id="L136">      throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, e.getMessage());</span>
    }
  }

  /**
   * (re-) Index a layer.
   *
   * @param searchIndexId the searchIndex id
   * @return the response entity (accepted or an error response)
   */
  @Operation(
      summary = &quot;Create or update a feature type index&quot;,
      description = &quot;Create or update a feature type index for a layer, will erase existing index if present&quot;)
  @ApiResponse(
      responseCode = &quot;202&quot;,
      description = &quot;Index create or update request accepted&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema =
                  @Schema(
                      example =
                          &quot;{\&quot;type\&quot;:\&quot;index\&quot;, \&quot;uuid\&quot;:\&quot;6308d26e-fe1e-4268-bb28-20db2cd06914\&quot;,\&quot;code\&quot;:202}&quot;)))
  @ApiResponse(
      responseCode = &quot;404&quot;,
      description = &quot;Layer does not have feature type&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema =
                  @Schema(
                      example =
                          &quot;{\&quot;message\&quot;:\&quot;Layer does not have feature type\&quot;,\&quot;code\&quot;:404}&quot;)))
  @ApiResponse(
      responseCode = &quot;400&quot;,
      description = &quot;Indexing WFS feature types is not supported&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema =
                  @Schema(
                      example =
                          &quot;{\&quot;message\&quot;:\&quot;Layer does not have valid feature type for indexing\&quot;,\&quot;code\&quot;:400}&quot;)))
  @ApiResponse(
      responseCode = &quot;500&quot;,
      description = &quot;Error while indexing&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema = @Schema(example = &quot;{\&quot;message\&quot;:\&quot;Some error message..\&quot;,\&quot;code\&quot;:500}&quot;)))
  @Transactional
  @Timed(value = &quot;index_feature_type&quot;, description = &quot;time spent to index feature type&quot;)
  @PutMapping(
      path = &quot;${tailormap-api.admin.base-path}/index/{searchIndexId}&quot;,
      produces = MediaType.APPLICATION_JSON_VALUE)
  public ResponseEntity&lt;?&gt; index(@PathVariable Long searchIndexId) {
<span class="nc" id="L192">    SearchIndex searchIndex = validateInputAndFindIndex(searchIndexId);</span>

<span class="nc bnc" id="L194" title="All 2 branches missed.">    if (searchIndex.getStatus() == SearchIndex.Status.INDEXING) {</span>
<span class="nc" id="L195">      throw new ResponseStatusException(</span>
          HttpStatus.CONFLICT, &quot;Indexing already in progress, check tasks overview before retrying&quot;);
    }

<span class="nc" id="L199">    boolean createNewIndex =</span>
<span class="nc bnc" id="L200" title="All 4 branches missed.">        (null == searchIndex.getLastIndexed() || searchIndex.getStatus() == SearchIndex.Status.INITIAL);</span>

<span class="nc bnc" id="L202" title="All 2 branches missed.">    boolean hasSchedule = (null != searchIndex.getSchedule()</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">        &amp;&amp; null != searchIndex.getSchedule().getUuid());</span>

    UUID taskUuid;
    try {
<span class="nc bnc" id="L207" title="All 2 branches missed.">      if (hasSchedule) {</span>
<span class="nc" id="L208">        taskUuid = searchIndex.getSchedule().getUuid();</span>
<span class="nc" id="L209">        startScheduledJobIndexing(searchIndex);</span>
      } else {
<span class="nc" id="L211">        taskUuid = startOneTimeJobIndexing(searchIndex);</span>
      }
<span class="nc" id="L213">      searchIndexRepository.save(searchIndex);</span>
<span class="nc" id="L214">    } catch (UnsupportedOperationException</span>
        | IOException
        | SolrServerException
        | SolrException
        | SchedulerException e) {
<span class="nc" id="L219">      logger.error(&quot;Error indexing&quot;, e);</span>
<span class="nc" id="L220">      searchIndex.setStatus(SearchIndex.Status.ERROR);</span>
<span class="nc" id="L221">      searchIndexRepository.save(searchIndex);</span>
<span class="nc" id="L222">      throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, e.getMessage());</span>
<span class="nc" id="L223">    }</span>

<span class="nc" id="L225">    logger.info(</span>
        &quot;Scheduled {} index for search index {}&quot;,
<span class="nc bnc" id="L227" title="All 2 branches missed.">        (createNewIndex ? &quot;creation of a new&quot; : &quot;update of&quot;),</span>
<span class="nc" id="L228">        searchIndex.getName());</span>
<span class="nc" id="L229">    return ResponseEntity.accepted()</span>
<span class="nc" id="L230">        .body(Map.of(</span>
            &quot;code&quot;,
<span class="nc" id="L232">            202,</span>
            Task.TYPE_KEY,
<span class="nc" id="L234">            TaskType.INDEX.getValue(),</span>
            Task.UUID_KEY,
            taskUuid,
            &quot;message&quot;,
            &quot;Indexing scheduled&quot;));
  }

  private UUID startOneTimeJobIndexing(SearchIndex searchIndex)
      throws SolrServerException, IOException, SchedulerException {
<span class="nc" id="L243">    UUID taskName = taskManagerService.createTask(</span>
        IndexTask.class,
<span class="nc" id="L245">        new TMJobDataMap(Map.of(</span>
            Task.TYPE_KEY,
            TaskType.INDEX,
            Task.DESCRIPTION_KEY,
<span class="nc" id="L249">            &quot;One-time indexing of &quot; + searchIndex.getName(),</span>
            IndexTask.INDEX_KEY,
<span class="nc" id="L251">            searchIndex.getId().toString(),</span>
            Task.PRIORITY_KEY,
<span class="nc" id="L253">            0)));</span>
<span class="nc" id="L254">    logger.info(&quot;One-time indexing job with UUID {} started&quot;, taskName);</span>
<span class="nc" id="L255">    return taskName;</span>
  }

  private void startScheduledJobIndexing(SearchIndex searchIndex) throws SchedulerException {
<span class="nc" id="L259">    JobKey jobKey = taskManagerService.getJobKey(</span>
<span class="nc" id="L260">        TaskType.INDEX, searchIndex.getSchedule().getUuid());</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">    if (null == jobKey) {</span>
<span class="nc" id="L262">      throw new SchedulerException(&quot;Indexing job not found in scheduler&quot;);</span>
    }
<span class="nc" id="L264">    scheduler.triggerJob(jobKey);</span>
<span class="nc" id="L265">    logger.info(</span>
        &quot;Indexing of scheduled job with UUID {} started&quot;,
<span class="nc" id="L267">        searchIndex.getSchedule().getUuid());</span>
<span class="nc" id="L268">  }</span>

  /**
   * Validate input and find the search index.
   *
   * @param searchIndexId the search index id
   * @return the search index
   * @throws ResponseStatusException if the search index is not found or the feature type is not found
   */
  private SearchIndex validateInputAndFindIndex(Long searchIndexId) {
    // check if solr is available
<span class="nc" id="L279">    this.pingSolr();</span>

    // check if search index exists
<span class="nc" id="L282">    SearchIndex searchIndex = searchIndexRepository</span>
<span class="nc" id="L283">        .findById(searchIndexId)</span>
<span class="nc" id="L284">        .orElseThrow(() -&gt; new ResponseStatusException(HttpStatus.NOT_FOUND, &quot;Search index not found&quot;));</span>

    // check if feature type exists
<span class="nc" id="L287">    TMFeatureType indexingFT = featureTypeRepository</span>
<span class="nc" id="L288">        .findById(searchIndex.getFeatureTypeId())</span>
<span class="nc" id="L289">        .orElseThrow(() -&gt; new ResponseStatusException(HttpStatus.NOT_FOUND, &quot;Feature type not found&quot;));</span>

<span class="nc bnc" id="L291" title="All 2 branches missed.">    if (TMFeatureSource.Protocol.WFS.equals(indexingFT.getFeatureSource().getProtocol())) {</span>
      // the search index should not exist for WFS feature types, but test just in case
<span class="nc" id="L293">      searchIndex</span>
<span class="nc" id="L294">          .setStatus(SearchIndex.Status.ERROR)</span>
<span class="nc" id="L295">          .setSummary(new SearchIndexSummary().errorMessage(&quot;WFS indexing not supported&quot;));</span>
<span class="nc" id="L296">      throw new ResponseStatusException(</span>
          HttpStatus.BAD_REQUEST, &quot;Layer does not have valid feature type for indexing&quot;);
    }
<span class="nc" id="L299">    return searchIndex;</span>
  }

  /**
   * Clear an index; does not remove the {@link SearchIndex} metadata.
   *
   * @param searchIndexId the searchindex id
   * @return the response entity ({@code 204 NOCONTENT} or an error response)
   */
  @Operation(summary = &quot;Clear index for a feature type&quot;, description = &quot;Clear index for the feature type&quot;)
  @ApiResponse(responseCode = &quot;204&quot;, description = &quot;Index cleared&quot;)
  @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Index not configured for feature type&quot;)
  @ApiResponse(
      responseCode = &quot;500&quot;,
      description = &quot;Error while clearing index&quot;,
      content =
          @Content(
              mediaType = MediaType.APPLICATION_JSON_VALUE,
              schema = @Schema(example = &quot;{\&quot;message\&quot;:\&quot;Some error message..\&quot;,\&quot;code\&quot;:500}&quot;)))
  @Timed(value = &quot;index_delete&quot;, description = &quot;time spent to delete an index of a feature type&quot;)
  @DeleteMapping(
      path = &quot;${tailormap-api.admin.base-path}/index/{searchIndexId}&quot;,
      produces = MediaType.APPLICATION_JSON_VALUE)
  @Transactional
  public ResponseEntity&lt;?&gt; clearIndex(@PathVariable Long searchIndexId) {
<span class="nc" id="L324">    try (SolrClient solrClient = solrService.getSolrClientForSearching();</span>
<span class="nc" id="L325">        SolrHelper solrHelper = new SolrHelper(solrClient).withQueryTimeout(solrQueryTimeout)) {</span>
<span class="nc" id="L326">      solrHelper.clearIndexForLayer(searchIndexId);</span>
      // do not delete the SearchIndex metadata object
      // searchIndexRepository.findById(searchIndexId).ifPresent(searchIndexRepository::delete);
<span class="nc" id="L329">      SearchIndex searchIndex = searchIndexRepository</span>
<span class="nc" id="L330">          .findById(searchIndexId)</span>
<span class="nc" id="L331">          .orElseThrow(() -&gt; new ResponseStatusException(HttpStatus.NOT_FOUND, &quot;Search index not found&quot;));</span>
<span class="nc" id="L332">      searchIndex</span>
<span class="nc" id="L333">          .setLastIndexed(null)</span>
<span class="nc" id="L334">          .setStatus(SearchIndex.Status.INITIAL)</span>
<span class="nc" id="L335">          .setSummary(new SearchIndexSummary().total(0));</span>
<span class="nc" id="L336">      searchIndexRepository.save(searchIndex);</span>
<span class="nc" id="L337">    } catch (IOException | SolrServerException | NoSuchElementException e) {</span>
<span class="nc" id="L338">      logger.warn(&quot;Error clearing index&quot;, e);</span>
<span class="nc" id="L339">      throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, e.getMessage());</span>
<span class="nc" id="L340">    }</span>

<span class="nc" id="L342">    logger.info(&quot;Index cleared for index {}&quot;, searchIndexId);</span>
<span class="nc" id="L343">    return ResponseEntity.noContent().build();</span>
  }

  @Override
  public void afterPropertiesSet() throws Exception {
<span class="nc bnc" id="L348" title="All 2 branches missed.">    if (solrService.isSolrServiceAvailable()) {</span>
<span class="nc" id="L349">      logger.info(&quot;Solr is available, initializing SolrAdminController.&quot;);</span>
      try {
        // there should be only one Solr ping task, so we delete any existing ones
<span class="nc" id="L352">        taskManagerService.deleteTasksByGroupName(TaskType.SOLR_PING.getValue());</span>
<span class="nc" id="L353">        final UUID taskUuid = taskManagerService.createTask(</span>
            SolrPingTask.class,
<span class="nc" id="L355">            new TMJobDataMap(Map.of(</span>
                Task.TYPE_KEY,
<span class="nc" id="L357">                TaskType.SOLR_PING.getValue(),</span>
                Task.DESCRIPTION_KEY,
                &quot;Ping Solr service for availability.&quot;,
                Task.PRIORITY_KEY,
<span class="nc" id="L361">                58)),</span>
            solrPingCron);
<span class="nc" id="L363">        logger.debug(&quot;Added Solr ping task with UUID: {}&quot;, taskUuid);</span>
<span class="nc" id="L364">      } catch (Exception e) {</span>
<span class="nc" id="L365">        logger.error(&quot;Error initializing Solr ping task&quot;, e);</span>
<span class="nc" id="L366">      }</span>
    } else {
<span class="nc" id="L368">      logger.info(&quot;Solr is not available, /search endpoint will not be functional.&quot;);</span>
    }
<span class="nc" id="L370">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>