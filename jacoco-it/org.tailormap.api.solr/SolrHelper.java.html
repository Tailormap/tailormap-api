<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SolrHelper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Tailormap API</a> &gt; <a href="index.source.html" class="el_package">org.tailormap.api.solr</a> &gt; <span class="el_source">SolrHelper.java</span></div><h1>SolrHelper.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2024 B3Partners B.V.
 *
 * SPDX-License-Identifier: MIT
 */
package org.tailormap.api.solr;

import static org.tailormap.api.scheduling.IndexTask.INDEX_KEY;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import java.io.IOException;
import java.lang.invoke.MethodHandles;
import java.math.BigDecimal;
import java.time.Duration;
import java.time.Instant;
import java.time.OffsetDateTime;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.function.Consumer;
import org.apache.solr.client.solrj.SolrClient;
import org.apache.solr.client.solrj.SolrQuery;
import org.apache.solr.client.solrj.SolrResponse;
import org.apache.solr.client.solrj.SolrServerException;
import org.apache.solr.client.solrj.impl.BaseHttpSolrClient;
import org.apache.solr.client.solrj.request.schema.FieldTypeDefinition;
import org.apache.solr.client.solrj.request.schema.SchemaRequest;
import org.apache.solr.client.solrj.response.QueryResponse;
import org.apache.solr.client.solrj.response.UpdateResponse;
import org.apache.solr.client.solrj.response.schema.SchemaResponse;
import org.apache.solr.common.SolrDocumentList;
import org.apache.solr.common.SolrException;
import org.geotools.api.data.Query;
import org.geotools.api.data.SimpleFeatureSource;
import org.geotools.api.feature.simple.SimpleFeature;
import org.geotools.data.simple.SimpleFeatureCollection;
import org.geotools.data.simple.SimpleFeatureIterator;
import org.locationtech.jts.geom.Geometry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.lang.NonNull;
import org.springframework.lang.Nullable;
import org.tailormap.api.admin.model.SearchIndexSummary;
import org.tailormap.api.admin.model.TaskProgressEvent;
import org.tailormap.api.geotools.featuresources.FeatureSourceFactoryHelper;
import org.tailormap.api.geotools.processing.GeometryProcessor;
import org.tailormap.api.persistence.SearchIndex;
import org.tailormap.api.persistence.TMFeatureType;
import org.tailormap.api.repository.SearchIndexRepository;
import org.tailormap.api.scheduling.TaskType;
import org.tailormap.api.util.Constants;
import org.tailormap.api.viewer.model.SearchDocument;
import org.tailormap.api.viewer.model.SearchResponse;

/**
 * Solr utility/wrapper class. This class provides methods to add or update a full-text feature type index for a layer,
 * find in the index for a layer, and clear the index for a layer. It also provides a method to close the Solr client as
 * well as automatically closing the client when used in a try-with-resources.
 */
public class SolrHelper implements AutoCloseable, Constants {
<span class="nc" id="L67">  private static final Logger logger =</span>
<span class="nc" id="L68">      LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());</span>

  /** the Solr field type name geometry fields: {@value #SOLR_SPATIAL_FIELDNAME}. */
  private static final String SOLR_SPATIAL_FIELDNAME = &quot;tm_geometry_rpt&quot;;

  private final SolrClient solrClient;

  /** the Solr search field definition requests for Tailormap. */
<span class="nc" id="L76">  private final Map&lt;String, SchemaRequest.AddField&gt; solrSearchFields = Map.of(</span>
      SEARCH_LAYER,
<span class="nc" id="L78">          new SchemaRequest.AddField(Map.of(</span>
              &quot;name&quot;, SEARCH_LAYER,
              &quot;type&quot;, &quot;string&quot;,
<span class="nc" id="L81">              &quot;indexed&quot;, true,</span>
<span class="nc" id="L82">              &quot;stored&quot;, true,</span>
<span class="nc" id="L83">              &quot;multiValued&quot;, false,</span>
<span class="nc" id="L84">              &quot;required&quot;, true,</span>
<span class="nc" id="L85">              &quot;uninvertible&quot;, false)),</span>
      INDEX_GEOM_FIELD,
          new SchemaRequest.AddField(
<span class="nc" id="L88">              Map.of(&quot;name&quot;, INDEX_GEOM_FIELD, &quot;type&quot;, SOLR_SPATIAL_FIELDNAME, &quot;stored&quot;, true)),</span>
      INDEX_SEARCH_FIELD,
<span class="nc" id="L90">          new SchemaRequest.AddField(Map.of(</span>
              &quot;name&quot;, INDEX_SEARCH_FIELD,
              &quot;type&quot;, &quot;text_general&quot;,
<span class="nc" id="L93">              &quot;indexed&quot;, true,</span>
<span class="nc" id="L94">              &quot;stored&quot;, true,</span>
<span class="nc" id="L95">              &quot;multiValued&quot;, true,</span>
<span class="nc" id="L96">              &quot;required&quot;, true,</span>
<span class="nc" id="L97">              &quot;uninvertible&quot;, false)),</span>
      INDEX_DISPLAY_FIELD,
<span class="nc" id="L99">          new SchemaRequest.AddField(Map.of(</span>
              &quot;name&quot;, INDEX_DISPLAY_FIELD,
              &quot;type&quot;, &quot;text_general&quot;,
<span class="nc" id="L102">              &quot;indexed&quot;, false,</span>
<span class="nc" id="L103">              &quot;stored&quot;, true,</span>
<span class="nc" id="L104">              &quot;multiValued&quot;, true,</span>
<span class="nc" id="L105">              &quot;required&quot;, true,</span>
<span class="nc" id="L106">              &quot;uninvertible&quot;, false)));</span>

<span class="nc" id="L108">  private int solrQueryTimeout = 7000;</span>
<span class="nc" id="L109">  private int solrBatchSize = 1000;</span>
<span class="nc" id="L110">  private String solrGeometryValidationRule = &quot;repairBuffer0&quot;;</span>

  /**
   * Create a configured {@code SolrHelper} object.
   *
   * @param solrClient the Solr client, this will be closed when this class is closed
   */
<span class="nc" id="L117">  public SolrHelper(@NotNull SolrClient solrClient) {</span>
<span class="nc" id="L118">    this.solrClient = solrClient;</span>
<span class="nc" id="L119">  }</span>

  /**
   * Configure this {@code SolrHelper} with a query timeout .
   *
   * @param solrQueryTimeout the query timeout in seconds
   */
  public SolrHelper withQueryTimeout(
      @Positive(message = &quot;Must use a positive integer for query timeout&quot;) int solrQueryTimeout) {
<span class="nc" id="L128">    this.solrQueryTimeout = solrQueryTimeout * 1000;</span>
<span class="nc" id="L129">    return this;</span>
  }

  /**
   * Configure this {@code SolrHelper} with a batch size for submitting documents to the Solr instance.
   *
   * @param solrBatchSize the batch size for indexing, must be greater than 0
   */
  public SolrHelper withBatchSize(@Positive(message = &quot;Must use a positive integer for batching&quot;) int solrBatchSize) {
<span class="nc" id="L138">    this.solrBatchSize = solrBatchSize;</span>
<span class="nc" id="L139">    return this;</span>
  }

  /**
   * Configure this {@code SolrHelper} to create a geometry field in Solr using the specified validation rule.
   *
   * @see &lt;a
   *     href=&quot;https://locationtech.github.io/spatial4j/apidocs/org/locationtech/spatial4j/context/jts/ValidationRule.html&quot;&gt;ValidationRule&lt;/a&gt;
   * @param solrGeometryValidationRule any of {@code &quot;error&quot;, &quot;none&quot;, &quot;repairBuffer0&quot;, &quot;repairConvexHull&quot;}
   */
  public SolrHelper withGeometryValidationRule(@NonNull String solrGeometryValidationRule) {
<span class="nc bnc" id="L150" title="All 2 branches missed.">    if (List.of(&quot;error&quot;, &quot;none&quot;, &quot;repairBuffer0&quot;, &quot;repairConvexHull&quot;).contains(solrGeometryValidationRule)) {</span>
<span class="nc" id="L151">      logger.trace(&quot;Setting geometry validation rule for Solr geometry field to {}&quot;, solrGeometryValidationRule);</span>
<span class="nc" id="L152">      this.solrGeometryValidationRule = solrGeometryValidationRule;</span>
    }
<span class="nc" id="L154">    return this;</span>
  }

  /**
   * Add or update a feature type index for a layer.
   *
   * @param searchIndex the search index config
   * @param tmFeatureType the feature type
   * @param featureSourceFactoryHelper the feature source factory helper
   * @param searchIndexRepository the search index repository, so we can save the {@code searchIndex}
   * @throws IOException if an I/O error occurs
   * @throws SolrServerException if a Solr error occurs
   * @return the possibly updated {@code searchIndex} object
   */
  @SuppressWarnings(&quot;FromTemporalAccessor&quot;)
  public SearchIndex addFeatureTypeIndex(
      @NotNull SearchIndex searchIndex,
      @NotNull TMFeatureType tmFeatureType,
      @NotNull FeatureSourceFactoryHelper featureSourceFactoryHelper,
      @NotNull SearchIndexRepository searchIndexRepository)
      throws IOException, SolrServerException {
    // use a dummy/logging listener when not given
<span class="nc" id="L176">    Consumer&lt;TaskProgressEvent&gt; progressListener = (event) -&gt; logger.debug(&quot;Progress event: {}&quot;, event);</span>

<span class="nc" id="L178">    return this.addFeatureTypeIndex(</span>
        searchIndex, tmFeatureType, featureSourceFactoryHelper, searchIndexRepository, progressListener, null);
  }

  /**
   * Add or update a feature type index for a layer.
   *
   * @param searchIndex the search index config
   * @param tmFeatureType the feature type
   * @param featureSourceFactoryHelper the feature source factory helper
   * @param searchIndexRepository the search index repository, so we can save the {@code searchIndex}
   * @param progressListener the progress listener callback
   * @param taskUuid the task UUID, when {@code null} we will attempt to use the UUID from the
   *     {@code searchIndex#getSchedule()}
   * @throws IOException if an I/O error occurs
   * @throws SolrServerException if a Solr error occurs
   * @return the possibly updated {@code searchIndex} object
   */
  @SuppressWarnings(&quot;FromTemporalAccessor&quot;)
  public SearchIndex addFeatureTypeIndex(
      @NotNull SearchIndex searchIndex,
      @NotNull TMFeatureType tmFeatureType,
      @NotNull FeatureSourceFactoryHelper featureSourceFactoryHelper,
      @NotNull SearchIndexRepository searchIndexRepository,
      @NotNull Consumer&lt;TaskProgressEvent&gt; progressListener,
      @Nullable UUID taskUuid)
      throws IOException, SolrServerException {

<span class="nc" id="L206">    createSchemaIfNotExists();</span>

<span class="nc" id="L208">    final Instant startedAt = Instant.now();</span>
<span class="nc" id="L209">    final OffsetDateTime startedAtOffset =</span>
<span class="nc" id="L210">        startedAt.atOffset(ZoneId.systemDefault().getRules().getOffset(startedAt));</span>

<span class="nc bnc" id="L212" title="All 4 branches missed.">    if (null == taskUuid &amp;&amp; null != searchIndex.getSchedule()) {</span>
      // this can be the case when this method is called directly such as when creating
      // the test data. This in itself is not a big problem; it just means that the uuid
      // in any progress events will be null (for that call).
<span class="nc" id="L216">      taskUuid = searchIndex.getSchedule().getUuid();</span>
    }

<span class="nc" id="L219">    SearchIndexSummary summary =</span>
<span class="nc" id="L220">        new SearchIndexSummary().startedAt(startedAtOffset).total(0).duration(0.0);</span>

<span class="nc bnc" id="L222" title="All 2 branches missed.">    if (null == searchIndex.getSearchFieldsUsed()) {</span>
<span class="nc" id="L223">      logger.warn(</span>
          &quot;No search fields configured for search index: {}, skipping index {}.&quot;,
<span class="nc" id="L225">          tmFeatureType.getName(),</span>
<span class="nc" id="L226">          searchIndex.getName());</span>
<span class="nc" id="L227">      return searchIndexRepository.save(searchIndex</span>
<span class="nc" id="L228">          .setStatus(SearchIndex.Status.ERROR)</span>
<span class="nc" id="L229">          .setSummary(summary.errorMessage(&quot;No search fields configured&quot;)));</span>
    }

<span class="nc" id="L232">    TaskProgressEvent taskProgressEvent = new TaskProgressEvent()</span>
<span class="nc" id="L233">        .type(TaskType.INDEX.getValue())</span>
<span class="nc" id="L234">        .uuid(taskUuid)</span>
<span class="nc" id="L235">        .startedAt(startedAtOffset)</span>
<span class="nc" id="L236">        .progress(0)</span>
<span class="nc" id="L237">        .taskData(Map.of(INDEX_KEY, searchIndex.getId()));</span>
<span class="nc" id="L238">    progressListener.accept(taskProgressEvent);</span>

    // set fields while filtering out hidden fields
<span class="nc" id="L241">    List&lt;String&gt; searchFields = searchIndex.getSearchFieldsUsed().stream()</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">        .filter(s -&gt; !tmFeatureType.getSettings().getHideAttributes().contains(s))</span>
<span class="nc" id="L243">        .toList();</span>
<span class="nc" id="L244">    List&lt;String&gt; displayFields = searchIndex.getSearchDisplayFieldsUsed().stream()</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">        .filter(s -&gt; !tmFeatureType.getSettings().getHideAttributes().contains(s))</span>
<span class="nc" id="L246">        .toList();</span>

<span class="nc bnc" id="L248" title="All 2 branches missed.">    if (searchFields.isEmpty()) {</span>
<span class="nc" id="L249">      logger.warn(</span>
          &quot;No valid search fields configured for feature type: {}, skipping index {}.&quot;,
<span class="nc" id="L251">          tmFeatureType.getName(),</span>
<span class="nc" id="L252">          searchIndex.getName());</span>
<span class="nc" id="L253">      return searchIndexRepository.save(searchIndex</span>
<span class="nc" id="L254">          .setStatus(SearchIndex.Status.ERROR)</span>
<span class="nc" id="L255">          .setSummary(summary.errorMessage(&quot;No search fields configured&quot;)));</span>
    }

    // add search and display properties to query
<span class="nc" id="L259">    Set&lt;String&gt; propertyNames = new HashSet&lt;&gt;();</span>

    // always try to add primary key and default geometry to geotools query
<span class="nc bnc" id="L262" title="All 2 branches missed.">    if (null == tmFeatureType.getPrimaryKeyAttribute()) {</span>
<span class="nc" id="L263">      logger.error(</span>
          &quot;No primary key attribute configured for feature type: {}, skipping index {}.&quot;,
<span class="nc" id="L265">          tmFeatureType.getName(),</span>
<span class="nc" id="L266">          searchIndex.getName());</span>
<span class="nc" id="L267">      return searchIndexRepository.save(searchIndex</span>
<span class="nc" id="L268">          .setStatus(SearchIndex.Status.ERROR)</span>
<span class="nc" id="L269">          .setSummary(summary.errorMessage(&quot;No primary key attribute configured&quot;)));</span>
    }
<span class="nc" id="L271">    propertyNames.add(tmFeatureType.getPrimaryKeyAttribute());</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">    if (null == tmFeatureType.getDefaultGeometryAttribute()) {</span>
<span class="nc" id="L273">      logger.error(</span>
          &quot;No default geometry attribute configured for feature type: {}, skipping index {}.&quot;,
<span class="nc" id="L275">          tmFeatureType.getName(),</span>
<span class="nc" id="L276">          searchIndex.getName());</span>
<span class="nc" id="L277">      return searchIndexRepository.save(searchIndex</span>
<span class="nc" id="L278">          .setStatus(SearchIndex.Status.ERROR)</span>
<span class="nc" id="L279">          .setSummary(summary.errorMessage(&quot;No default geometry attribute configured&quot;)));</span>
    }
<span class="nc" id="L281">    propertyNames.add(tmFeatureType.getDefaultGeometryAttribute());</span>
<span class="nc" id="L282">    propertyNames.addAll(searchFields);</span>

<span class="nc bnc" id="L284" title="All 2 branches missed.">    if (!displayFields.isEmpty()) {</span>
<span class="nc" id="L285">      propertyNames.addAll(displayFields);</span>
    }

<span class="nc" id="L288">    clearIndexForLayer(searchIndex.getId());</span>

<span class="nc" id="L290">    logger.info(&quot;Indexing started for index: {}, feature type: {}&quot;, searchIndex.getName(), tmFeatureType.getName());</span>
<span class="nc" id="L291">    searchIndex = searchIndexRepository.save(searchIndex.setStatus(SearchIndex.Status.INDEXING));</span>

    // collect features to index
<span class="nc" id="L294">    SimpleFeatureSource fs = featureSourceFactoryHelper.openGeoToolsFeatureSource(tmFeatureType);</span>
<span class="nc" id="L295">    Query q = new Query(fs.getName().toString());</span>
    // filter out any hidden properties (there should be none though)
<span class="nc" id="L297">    tmFeatureType.getSettings().getHideAttributes().forEach(propertyNames::remove);</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">    if (propertyNames.isEmpty()) {</span>
<span class="nc" id="L299">      logger.warn(</span>
          &quot;No valid properties to index for feature type: {}, skipping index {}.&quot;,
<span class="nc" id="L301">          tmFeatureType.getName(),</span>
<span class="nc" id="L302">          searchIndex.getName());</span>
<span class="nc" id="L303">      return searchIndexRepository.save(searchIndex</span>
<span class="nc" id="L304">          .setStatus(SearchIndex.Status.ERROR)</span>
<span class="nc" id="L305">          .setSummary(</span>
<span class="nc" id="L306">              summary.errorMessage(&quot;No valid properties to index. Check if any properties are hidden.&quot;)));</span>
    }
<span class="nc" id="L308">    q.setPropertyNames(List.copyOf(propertyNames));</span>
<span class="nc" id="L309">    q.setStartIndex(0);</span>
    // TODO: make maxFeatures configurable?
    // q.setMaxFeatures(Integer.MAX_VALUE);
<span class="nc" id="L312">    logger.trace(&quot;Indexing query: {}&quot;, q);</span>
<span class="nc" id="L313">    SimpleFeatureCollection simpleFeatureCollection = fs.getFeatures(q);</span>
<span class="nc" id="L314">    final int total = simpleFeatureCollection.size();</span>
<span class="nc" id="L315">    List&lt;FeatureIndexingDocument&gt; docsBatch = new ArrayList&lt;&gt;(solrBatchSize);</span>
    // TODO this does not currently batch/page the feature source query, this doesn't seem to be an
    //   issue for now but could be if the feature source is very, very large or slow
    UpdateResponse updateResponse;
<span class="nc" id="L319">    int indexCounter = 0;</span>
<span class="nc" id="L320">    int indexSkippedCounter = 0;</span>
<span class="nc" id="L321">    try (SimpleFeatureIterator iterator = simpleFeatureCollection.features()) {</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">      while (iterator.hasNext()) {</span>
<span class="nc" id="L323">        indexCounter++;</span>
<span class="nc" id="L324">        SimpleFeature feature = iterator.next();</span>
        // note that this will create a unique document
<span class="nc" id="L326">        FeatureIndexingDocument doc = new FeatureIndexingDocument(feature.getID(), searchIndex.getId());</span>
<span class="nc" id="L327">        List&lt;String&gt; searchValues = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L328">        List&lt;String&gt; displayValues = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L329">        propertyNames.forEach(propertyName -&gt; {</span>
<span class="nc" id="L330">          Object value = feature.getAttribute(propertyName);</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">          if (value != null) {</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">            if (value instanceof Geometry</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">                &amp;&amp; propertyName.equals(tmFeatureType.getDefaultGeometryAttribute())) {</span>
              // We could use GeoJSON, but WKT is more compact and that would also incur a
              // change to the API
<span class="nc" id="L336">              doc.setGeometry(GeometryProcessor.processGeometry(value, true, true, null));</span>
            } else {
<span class="nc bnc" id="L338" title="All 2 branches missed.">              if (searchFields.contains(propertyName)) {</span>
<span class="nc" id="L339">                searchValues.add(value.toString());</span>
              }
<span class="nc bnc" id="L341" title="All 2 branches missed.">              if (displayFields.contains(propertyName)) {</span>
<span class="nc" id="L342">                displayValues.add(value.toString());</span>
              }
            }
          }
<span class="nc" id="L346">        });</span>
<span class="nc bnc" id="L347" title="All 4 branches missed.">        if (searchValues.isEmpty() || displayValues.isEmpty()) {</span>
          // this is a record/document that can either not be found or not be displayed
<span class="nc" id="L349">          logger.trace(</span>
              &quot;No search or display values found for feature: {} in feature type: {}, skipped for indexing&quot;,
<span class="nc" id="L351">              feature.getID(),</span>
<span class="nc" id="L352">              tmFeatureType.getName());</span>
<span class="nc" id="L353">          indexSkippedCounter++;</span>
        } else {
<span class="nc" id="L355">          doc.setSearchFields(searchValues.toArray(new String[0]));</span>
<span class="nc" id="L356">          doc.setDisplayFields(displayValues.toArray(new String[0]));</span>
<span class="nc" id="L357">          docsBatch.add(doc);</span>
        }

<span class="nc bnc" id="L360" title="All 2 branches missed.">        if (indexCounter % solrBatchSize == 0) {</span>
<span class="nc" id="L361">          updateResponse = solrClient.addBeans(docsBatch, solrQueryTimeout);</span>
<span class="nc" id="L362">          logger.info(</span>
              &quot;Added {} documents of {} to index, result status: {}&quot;,
<span class="nc" id="L364">              indexCounter - indexSkippedCounter,</span>
<span class="nc" id="L365">              total,</span>
<span class="nc" id="L366">              updateResponse.getStatus());</span>
<span class="nc" id="L367">          progressListener.accept(</span>
<span class="nc" id="L368">              taskProgressEvent.total(total).progress((indexCounter - indexSkippedCounter)));</span>
<span class="nc" id="L369">          docsBatch.clear();</span>
        }
<span class="nc" id="L371">      }</span>
    } finally {
<span class="nc bnc" id="L373" title="All 2 branches missed.">      if (fs.getDataStore() != null) fs.getDataStore().dispose();</span>
    }

<span class="nc bnc" id="L376" title="All 2 branches missed.">    if (!docsBatch.isEmpty()) {</span>
<span class="nc" id="L377">      solrClient.addBeans(docsBatch, solrQueryTimeout);</span>
<span class="nc" id="L378">      logger.info(&quot;Added last {} documents of {} to index&quot;, docsBatch.size(), total);</span>
<span class="nc" id="L379">      progressListener.accept(taskProgressEvent</span>
<span class="nc" id="L380">          .progress((indexCounter - indexSkippedCounter))</span>
<span class="nc" id="L381">          .total(total));</span>
    }
<span class="nc" id="L383">    final Instant finishedAt = Instant.now();</span>
<span class="nc" id="L384">    final OffsetDateTime finishedAtOffset =</span>
<span class="nc" id="L385">        finishedAt.atOffset(ZoneId.systemDefault().getRules().getOffset(finishedAt));</span>
<span class="nc" id="L386">    Duration processTime = Duration.between(startedAt, finishedAt).abs();</span>
<span class="nc" id="L387">    logger.info(</span>
        &quot;Indexing finished for index: {}, feature type: {} at {} in {}&quot;,
<span class="nc" id="L389">        searchIndex.getName(),</span>
<span class="nc" id="L390">        tmFeatureType.getName(),</span>
        finishedAtOffset,
        processTime);
<span class="nc" id="L393">    updateResponse = this.solrClient.commit();</span>
<span class="nc" id="L394">    logger.trace(&quot;Update response commit status: {}&quot;, updateResponse.getStatus());</span>

<span class="nc bnc" id="L396" title="All 2 branches missed.">    if (indexSkippedCounter &gt; 0) {</span>
<span class="nc" id="L397">      logger.warn(</span>
<span class="nc" id="L398">          &quot;{} features were skipped because no search or display values were found.&quot;, indexSkippedCounter);</span>
    }

<span class="nc" id="L401">    return searchIndexRepository.save(searchIndex</span>
<span class="nc" id="L402">        .setLastIndexed(finishedAtOffset)</span>
<span class="nc" id="L403">        .setStatus(SearchIndex.Status.INDEXED)</span>
<span class="nc" id="L404">        .setSummary(summary.total(total)</span>
<span class="nc" id="L405">            .skippedCounter(indexSkippedCounter)</span>
<span class="nc" id="L406">            .duration(BigDecimal.valueOf(processTime.getSeconds())</span>
<span class="nc" id="L407">                .add(BigDecimal.valueOf(processTime.getNano(), 9))</span>
<span class="nc" id="L408">                .doubleValue())</span>
<span class="nc" id="L409">            .errorMessage(null)));</span>
  }

  /**
   * Clear the index for a layer.
   *
   * @param searchLayerId the layer id
   * @throws IOException if an I/O error occurs
   * @throws SolrServerException if a Solr error occurs
   */
  public void clearIndexForLayer(@NotNull Long searchLayerId) throws IOException, SolrServerException {

<span class="nc" id="L421">    QueryResponse response =</span>
<span class="nc" id="L422">        solrClient.query(new SolrQuery(&quot;exists(query(&quot; + SEARCH_LAYER + &quot;:&quot; + searchLayerId + &quot;))&quot;));</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">    if (response.getResults().getNumFound() &gt; 0) {</span>
<span class="nc" id="L424">      logger.info(&quot;Clearing index for searchLayer {}&quot;, searchLayerId);</span>
<span class="nc" id="L425">      UpdateResponse updateResponse = solrClient.deleteByQuery(SEARCH_LAYER + &quot;:&quot; + searchLayerId);</span>
<span class="nc" id="L426">      logger.trace(&quot;Delete response status: {}&quot;, updateResponse.getStatus());</span>
<span class="nc" id="L427">      updateResponse = solrClient.commit();</span>
<span class="nc" id="L428">      logger.trace(&quot;Commit response status: {}&quot;, updateResponse.getStatus());</span>
<span class="nc" id="L429">    } else {</span>
<span class="nc" id="L430">      logger.info(&quot;No index to clear for layer {}&quot;, searchLayerId);</span>
    }
<span class="nc" id="L432">  }</span>

  /**
   * Search in the index for a layer. The given query is augmented to filter on the {@code solrLayerId}.
   *
   * @param searchIndex the search index
   * @param solrQuery the query, when {@code null} or empty, the query is set to {@code *} (match all)
   * @param solrPoint the point to search around, in (x y) format
   * @param solrDistance the distance to search around the point in Solr distance units (kilometers)
   * @param start the start index, starting at 0
   * @param numResultsToReturn the number of results to return
   * @return the documents
   * @throws IOException if an I/O error occurs
   * @throws SolrServerException if a Solr error occurs
   */
  public SearchResponse findInIndex(
      @NotNull SearchIndex searchIndex,
      String solrQuery,
      String solrFilterQuery,
      String solrPoint,
      Double solrDistance,
      int start,
      int numResultsToReturn)
      throws IOException, SolrServerException, SolrException {

<span class="nc bnc" id="L457" title="All 4 branches missed.">    if (null == solrQuery || solrQuery.isBlank()) {</span>
<span class="nc" id="L458">      solrQuery = &quot;*&quot;;</span>
    }

<span class="nc" id="L461">    logger.info(&quot;Query index for '{}' in {} (id {})&quot;, solrQuery, searchIndex.getName(), searchIndex.getId());</span>

    // TODO We could escape special/syntax characters, but that also prevents using
    //      keys like ~ and *
    // solrQuery = ClientUtils.escapeQueryChars(solrQuery);

<span class="nc" id="L467">    final SolrQuery query = new SolrQuery(INDEX_SEARCH_FIELD + &quot;:&quot; + solrQuery)</span>
<span class="nc" id="L468">        .setShowDebugInfo(logger.isDebugEnabled())</span>
<span class="nc" id="L469">        .setTimeAllowed(solrQueryTimeout)</span>
<span class="nc" id="L470">        .setIncludeScore(true)</span>
<span class="nc" id="L471">        .setFields(SEARCH_ID_FIELD, INDEX_DISPLAY_FIELD, INDEX_GEOM_FIELD)</span>
<span class="nc" id="L472">        .addFilterQuery(SEARCH_LAYER + &quot;:&quot; + searchIndex.getId())</span>
<span class="nc" id="L473">        .setSort(&quot;score&quot;, SolrQuery.ORDER.desc)</span>
<span class="nc" id="L474">        .addSort(SEARCH_ID_FIELD, SolrQuery.ORDER.asc)</span>
<span class="nc" id="L475">        .setRows(numResultsToReturn)</span>
<span class="nc" id="L476">        .setStart(start);</span>

<span class="nc bnc" id="L478" title="All 4 branches missed.">    if (null != solrFilterQuery &amp;&amp; !solrFilterQuery.isBlank()) {</span>
<span class="nc" id="L479">      query.addFilterQuery(solrFilterQuery);</span>
    }
<span class="nc bnc" id="L481" title="All 4 branches missed.">    if (null != solrPoint &amp;&amp; null != solrDistance) {</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">      if (null == solrFilterQuery</span>
<span class="nc bnc" id="L483" title="All 4 branches missed.">          || !(solrFilterQuery.startsWith(&quot;{!geofilt&quot;) || solrFilterQuery.startsWith(&quot;{!bbox&quot;))) {</span>
<span class="nc" id="L484">        query.addFilterQuery(&quot;{!geofilt sfield=&quot; + INDEX_GEOM_FIELD + &quot;}&quot;);</span>
      }
<span class="nc" id="L486">      query.add(&quot;pt&quot;, solrPoint);</span>
<span class="nc" id="L487">      query.add(&quot;d&quot;, solrDistance.toString());</span>
    }
<span class="nc" id="L489">    query.set(&quot;q.op&quot;, &quot;AND&quot;);</span>
<span class="nc" id="L490">    logger.info(&quot;Solr query: {}&quot;, query);</span>

<span class="nc" id="L492">    final QueryResponse response = solrClient.query(query);</span>
<span class="nc" id="L493">    logger.trace(&quot;response: {}&quot;, response);</span>

<span class="nc" id="L495">    final SolrDocumentList solrDocumentList = response.getResults();</span>
<span class="nc" id="L496">    logger.debug(&quot;Found {} solr documents&quot;, solrDocumentList.getNumFound());</span>
<span class="nc" id="L497">    final SearchResponse searchResponse = new SearchResponse()</span>
<span class="nc" id="L498">        .total(solrDocumentList.getNumFound())</span>
<span class="nc" id="L499">        .start(response.getResults().getStart())</span>
<span class="nc" id="L500">        .maxScore(solrDocumentList.getMaxScore());</span>
<span class="nc" id="L501">    response.getResults().forEach(solrDocument -&gt; {</span>
<span class="nc" id="L502">      List&lt;String&gt; displayValues = solrDocument.getFieldValues(INDEX_DISPLAY_FIELD).stream()</span>
<span class="nc" id="L503">          .map(Object::toString)</span>
<span class="nc" id="L504">          .toList();</span>
<span class="nc" id="L505">      searchResponse.addDocumentsItem(new SearchDocument()</span>
<span class="nc" id="L506">          .fid(solrDocument.getFieldValue(SEARCH_ID_FIELD).toString())</span>
<span class="nc" id="L507">          .geometry(solrDocument.getFieldValue(INDEX_GEOM_FIELD).toString())</span>
<span class="nc" id="L508">          .displayValues(displayValues));</span>
<span class="nc" id="L509">    });</span>

<span class="nc" id="L511">    return searchResponse;</span>
  }

  /**
   * Close the wrapped Solr client.
   *
   * @throws IOException if an I/O error occurs
   */
  @Override
  public void close() throws IOException {
<span class="nc bnc" id="L521" title="All 2 branches missed.">    if (null != this.solrClient) this.solrClient.close();</span>
<span class="nc" id="L522">  }</span>

  private boolean checkSchemaIfFieldExists(String fieldName) {
<span class="nc" id="L525">    SchemaRequest.Field fieldCheck = new SchemaRequest.Field(fieldName);</span>
    try {
<span class="nc" id="L527">      SchemaResponse.FieldResponse isField = fieldCheck.process(solrClient);</span>
<span class="nc" id="L528">      logger.debug(&quot;Field {} exists&quot;, isField.getField());</span>
<span class="nc" id="L529">      return true;</span>
<span class="nc" id="L530">    } catch (SolrServerException | BaseHttpSolrClient.RemoteSolrException e) {</span>
<span class="nc" id="L531">      logger.debug(&quot;Field {} does not exist or could not be retrieved. Assuming it does not exist.&quot;, fieldName);</span>
<span class="nc" id="L532">    } catch (IOException e) {</span>
<span class="nc" id="L533">      logger.error(&quot;Tried getting field: {}, but failed.&quot;, fieldName, e);</span>
<span class="nc" id="L534">    }</span>
<span class="nc" id="L535">    return false;</span>
  }

  /**
   * @param fieldName the name of the field to create
   * @throws SolrServerException if a Solr error occurs
   * @throws IOException if an I/O error occurs
   */
  private void createSchemaFieldIfNotExists(String fieldName) throws SolrServerException, IOException {
<span class="nc bnc" id="L544" title="All 2 branches missed.">    if (!checkSchemaIfFieldExists(fieldName)) {</span>
<span class="nc" id="L545">      logger.info(&quot;Creating Solr field {}.&quot;, fieldName);</span>
<span class="nc" id="L546">      SchemaRequest.AddField schemaRequest = solrSearchFields.get(fieldName);</span>
<span class="nc" id="L547">      SolrResponse response = schemaRequest.process(solrClient);</span>
<span class="nc" id="L548">      logger.debug(&quot;Field type {} created&quot;, response);</span>
<span class="nc" id="L549">      solrClient.commit();</span>
    }
<span class="nc" id="L551">  }</span>

  /** Programmatically create the schema if it does not exist. */
  private void createSchemaIfNotExists() {
<span class="nc" id="L555">    solrSearchFields.forEach((key, value) -&gt; {</span>
      try {
<span class="nc bnc" id="L557" title="All 2 branches missed.">        if (key.equals(INDEX_GEOM_FIELD)) {</span>
<span class="nc" id="L558">          createGeometryFieldTypeIfNotExists();</span>
        }
<span class="nc" id="L560">        createSchemaFieldIfNotExists(key);</span>
<span class="nc" id="L561">      } catch (SolrServerException | IOException e) {</span>
<span class="nc" id="L562">        logger.error(</span>
            &quot;Error creating schema field: {} indexing may fail. Details: {}&quot;,
            key,
<span class="nc" id="L565">            e.getLocalizedMessage(),</span>
            e);
<span class="nc" id="L567">      }</span>
<span class="nc" id="L568">    });</span>
<span class="nc" id="L569">  }</span>

  private void createGeometryFieldTypeIfNotExists() throws SolrServerException, IOException {
<span class="nc" id="L572">    SchemaRequest.FieldType fieldTypeCheck = new SchemaRequest.FieldType(SOLR_SPATIAL_FIELDNAME);</span>
    try {
<span class="nc" id="L574">      SchemaResponse.FieldTypeResponse isFieldType = fieldTypeCheck.process(solrClient);</span>
<span class="nc" id="L575">      logger.debug(&quot;Field type {} exists&quot;, isFieldType.getFieldType());</span>
<span class="nc" id="L576">      return;</span>
<span class="nc" id="L577">    } catch (SolrServerException | BaseHttpSolrClient.RemoteSolrException e) {</span>
<span class="nc" id="L578">      logger.debug(</span>
          &quot;Field type {} does not exist or could not be retrieved. Assuming it does not exist.&quot;,
          SOLR_SPATIAL_FIELDNAME);
<span class="nc" id="L581">    } catch (IOException e) {</span>
<span class="nc" id="L582">      logger.error(&quot;Tried getting field type: {}, but failed.&quot;, SOLR_SPATIAL_FIELDNAME, e);</span>
<span class="nc" id="L583">    }</span>

<span class="nc" id="L585">    logger.info(</span>
        &quot;Creating Solr field type for {} with validation rule {}&quot;,
        SOLR_SPATIAL_FIELDNAME,
        solrGeometryValidationRule);
<span class="nc" id="L589">    FieldTypeDefinition spatialFieldTypeDef = new FieldTypeDefinition();</span>
<span class="nc" id="L590">    Map&lt;String, Object&gt; spatialFieldAttributes = new HashMap&lt;&gt;(Map.of(</span>
        &quot;name&quot;, SOLR_SPATIAL_FIELDNAME,
        &quot;class&quot;, &quot;solr.SpatialRecursivePrefixTreeFieldType&quot;,
        &quot;spatialContextFactory&quot;, &quot;JTS&quot;,
<span class="nc" id="L594">        &quot;geo&quot;, false,</span>
        &quot;distanceUnits&quot;, &quot;kilometers&quot;,
        &quot;distCalculator&quot;, &quot;cartesian&quot;,
        &quot;format&quot;, &quot;WKT&quot;,
<span class="nc" id="L598">        &quot;autoIndex&quot;, true,</span>
        &quot;distErrPct&quot;, &quot;0.025&quot;,
        &quot;maxDistErr&quot;, &quot;0.001&quot;));
<span class="nc" id="L601">    spatialFieldAttributes.putAll(Map.of(</span>
        &quot;prefixTree&quot;,
        &quot;packedQuad&quot;,
        // see
        // https://locationtech.github.io/spatial4j/apidocs/org/locationtech/spatial4j/context/jts/ValidationRule.html
        &quot;validationRule&quot;,
        this.solrGeometryValidationRule,
        // NOTE THE ODDITY in coordinate order of &quot;worldBounds&quot;,
        // &quot;ENVELOPE(minX, maxX, maxY, minY)&quot;
        &quot;worldBounds&quot;,
        // webmercator / EPSG:3857 projected bounds
        &quot;ENVELOPE(-20037508.34, 20037508.34, 20048966.1, -20048966.1)&quot;
        // Amersfoort/RD new / EPSG:28992 projected bounds
        // &quot;ENVELOPE(482.06, 284182.97, 637049.52, 306602.42)&quot;
        ));
<span class="nc" id="L616">    spatialFieldTypeDef.setAttributes(spatialFieldAttributes);</span>
<span class="nc" id="L617">    SchemaRequest.AddFieldType spatialFieldType = new SchemaRequest.AddFieldType(spatialFieldTypeDef);</span>
<span class="nc" id="L618">    spatialFieldType.process(solrClient);</span>
<span class="nc" id="L619">    solrClient.commit();</span>
<span class="nc" id="L620">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>