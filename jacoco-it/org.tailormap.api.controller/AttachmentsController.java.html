<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AttachmentsController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Tailormap API</a> &gt; <a href="index.source.html" class="el_package">org.tailormap.api.controller</a> &gt; <span class="el_source">AttachmentsController.java</span></div><h1>AttachmentsController.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2025 B3Partners B.V.
 *
 * SPDX-License-Identifier: MIT
 */
package org.tailormap.api.controller;

import com.google.common.base.Splitter;
import jakarta.validation.Valid;
import java.io.IOException;
import java.io.Serializable;
import java.lang.invoke.MethodHandles;
import java.nio.ByteBuffer;
import java.sql.SQLException;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import java.util.UUID;
import java.util.regex.Pattern;
import org.geotools.api.data.Query;
import org.geotools.api.data.SimpleFeatureSource;
import org.geotools.api.filter.Filter;
import org.geotools.api.filter.FilterFactory;
import org.geotools.data.simple.SimpleFeatureIterator;
import org.geotools.factory.CommonFactoryFinder;
import org.geotools.util.factory.GeoTools;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.server.ResponseStatusException;
import org.tailormap.api.annotation.AppRestController;
import org.tailormap.api.geotools.featuresources.AttachmentsHelper;
import org.tailormap.api.geotools.featuresources.FeatureSourceFactoryHelper;
import org.tailormap.api.persistence.Application;
import org.tailormap.api.persistence.GeoService;
import org.tailormap.api.persistence.TMFeatureType;
import org.tailormap.api.persistence.json.AppTreeLayerNode;
import org.tailormap.api.persistence.json.AttachmentAttributeType;
import org.tailormap.api.persistence.json.GeoServiceLayer;
import org.tailormap.api.util.EditUtil;
import org.tailormap.api.viewer.model.AttachmentMetadata;

@AppRestController
@Validated
public class AttachmentsController {

<span class="nc" id="L57">  private static final Logger logger =</span>
<span class="nc" id="L58">      LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());</span>

  private final EditUtil editUtil;
  private final FeatureSourceFactoryHelper featureSourceFactoryHelper;
<span class="nc" id="L62">  private final FilterFactory ff = CommonFactoryFinder.getFilterFactory(GeoTools.getDefaultHints());</span>

<span class="nc" id="L64">  public AttachmentsController(EditUtil editUtil, FeatureSourceFactoryHelper featureSourceFactoryHelper) {</span>
<span class="nc" id="L65">    this.editUtil = editUtil;</span>
<span class="nc" id="L66">    this.featureSourceFactoryHelper = featureSourceFactoryHelper;</span>
<span class="nc" id="L67">  }</span>

  /**
   * Add an attachment to a feature
   *
   * @param appTreeLayerNode the application tree layer node
   * @param service the geo service
   * @param layer the geo service layer
   * @param application the application
   * @param featureId the feature id
   * @param attachment the attachment metadata
   * @param fileData the attachment file data
   * @return the response entity
   */
  @PostMapping(
      path = {
        &quot;${tailormap-api.base-path}/{viewerKind}/{viewerName}/layer/{appLayerId}/feature/{featureId}/attachments&quot;
      },
      consumes = MediaType.MULTIPART_FORM_DATA_VALUE,
      produces = MediaType.APPLICATION_JSON_VALUE)
  @Transactional
  public ResponseEntity&lt;Serializable&gt; addAttachment(
      @ModelAttribute AppTreeLayerNode appTreeLayerNode,
      @ModelAttribute GeoService service,
      @ModelAttribute GeoServiceLayer layer,
      @ModelAttribute Application application,
      @PathVariable String featureId,
      @RequestPart(&quot;attachmentMetadata&quot;) AttachmentMetadata attachment,
      @RequestPart(&quot;attachment&quot;) byte[] fileData) {

<span class="nc" id="L97">    editUtil.checkEditAuthorisation();</span>

<span class="nc" id="L99">    TMFeatureType tmFeatureType = editUtil.getEditableFeatureType(application, appTreeLayerNode, service, layer);</span>

<span class="nc" id="L101">    Object primaryKey = getFeaturePrimaryKeyByFid(tmFeatureType, featureId);</span>

<span class="nc" id="L103">    Set&lt;@Valid AttachmentAttributeType&gt; attachmentAttrSet =</span>
<span class="nc" id="L104">        tmFeatureType.getSettings().getAttachmentAttributes();</span>
<span class="nc bnc" id="L105" title="All 4 branches missed.">    if (attachmentAttrSet == null || attachmentAttrSet.isEmpty()) {</span>
<span class="nc" id="L106">      throw new ResponseStatusException(HttpStatus.BAD_REQUEST, &quot;Layer does not support attachments&quot;);</span>
    }

<span class="nc" id="L109">    AttachmentAttributeType attachmentAttribute = attachmentAttrSet.stream()</span>
<span class="nc" id="L110">        .filter(attr -&gt; attr.getAttributeName().equals(attachment.getAttributeName()))</span>
<span class="nc" id="L111">        .findFirst()</span>
<span class="nc" id="L112">        .orElseThrow(() -&gt; new ResponseStatusException(</span>
            HttpStatus.BAD_REQUEST,
<span class="nc" id="L114">            &quot;Layer does not support attachments for attribute &quot; + attachment.getAttributeName()));</span>

<span class="nc bnc" id="L116" title="All 2 branches missed.">    if (attachmentAttribute.getMaxAttachmentSize() != null</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">        &amp;&amp; attachmentAttribute.getMaxAttachmentSize() &lt; fileData.length) {</span>
<span class="nc" id="L118">      throw new ResponseStatusException(</span>
          HttpStatus.BAD_REQUEST,
          &quot;Attachment size %d exceeds maximum of %d&quot;
<span class="nc" id="L121">              .formatted(fileData.length, attachmentAttribute.getMaxAttachmentSize()));</span>
    }

<span class="nc bnc" id="L124" title="All 2 branches missed.">    if (attachmentAttribute.getMimeType() != null) {</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">      if (!validateMimeTypeAccept(</span>
<span class="nc" id="L126">          attachmentAttribute.getMimeType(), attachment.getFileName(), attachment.getMimeType())) {</span>
<span class="nc" id="L127">        throw new ResponseStatusException(HttpStatus.BAD_REQUEST, &quot;File type or extension not allowed&quot;);</span>
      }
    }

<span class="nc" id="L131">    logger.debug(&quot;Using attachment attribute {}&quot;, attachmentAttribute);</span>

    AttachmentMetadata response;
    try {
<span class="nc" id="L135">      response = AttachmentsHelper.insertAttachment(tmFeatureType, attachment, primaryKey, fileData);</span>
<span class="nc" id="L136">    } catch (IOException | SQLException e) {</span>
<span class="nc" id="L137">      throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, e.getMessage());</span>
<span class="nc" id="L138">    }</span>

<span class="nc" id="L140">    return new ResponseEntity&lt;&gt;(response, HttpStatus.CREATED);</span>
  }

  /**
   * Validate as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input/file#accept&quot;&gt;file
   * input &quot;accept&quot; attribute&lt;/a&gt;.
   *
   * @param acceptList comma-separated list of MIME types and file extensions to validate against
   * @param fileName name of the file to validate
   * @param mimeType MIME type of the file to validate
   * @return true if the file's extension or MIME type matches one of the accepted types, false otherwise
   */
  private static boolean validateMimeTypeAccept(String acceptList, String fileName, String mimeType) {
<span class="nc" id="L153">    Iterable&lt;String&gt; allowedMimeTypes =</span>
<span class="nc" id="L154">        Splitter.on(Pattern.compile(&quot;,\\s*&quot;)).split(acceptList);</span>
<span class="nc" id="L155">    final Locale locale = Locale.ENGLISH;</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">    for (String allowedType : allowedMimeTypes) {</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">      if (allowedType.startsWith(&quot;.&quot;)) {</span>
        // Check file extension
<span class="nc bnc" id="L159" title="All 2 branches missed.">        if (fileName.toLowerCase(locale).endsWith(allowedType.toLowerCase(locale))) {</span>
<span class="nc" id="L160">          return true;</span>
        }
<span class="nc bnc" id="L162" title="All 2 branches missed.">      } else if (allowedType.endsWith(&quot;/*&quot;)) {</span>
        // Check mime type category (e.g. image/*)
<span class="nc" id="L164">        String category = allowedType.substring(0, allowedType.length() - 1);</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (mimeType.startsWith(category)) {</span>
<span class="nc" id="L166">          return true;</span>
        }
<span class="nc" id="L168">      } else {</span>
        // Check exact mime type match
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (mimeType.equals(allowedType)) {</span>
<span class="nc" id="L171">          return true;</span>
        }
      }
<span class="nc" id="L174">    }</span>
<span class="nc" id="L175">    return false;</span>
  }

  /**
   * List attachments for a feature.
   *
   * @param appTreeLayerNode the application tree layer node
   * @param service the geo service
   * @param layer the geo service layer
   * @param application the application
   * @param featureId the feature id
   * @return the response entity containing a list of attachment metadata
   */
  @GetMapping(
      path = {
        &quot;${tailormap-api.base-path}/{viewerKind}/{viewerName}/layer/{appLayerId}/feature/{featureId}/attachments&quot;
      },
      produces = MediaType.APPLICATION_JSON_VALUE)
  @Transactional
  public ResponseEntity&lt;List&lt;AttachmentMetadata&gt;&gt; listAttachments(
      @ModelAttribute AppTreeLayerNode appTreeLayerNode,
      @ModelAttribute GeoService service,
      @ModelAttribute GeoServiceLayer layer,
      @ModelAttribute Application application,
      @PathVariable String featureId) {

<span class="nc" id="L201">    TMFeatureType tmFeatureType = editUtil.getEditableFeatureType(application, appTreeLayerNode, service, layer);</span>

<span class="nc" id="L203">    checkFeatureTypeSupportsAttachments(tmFeatureType);</span>
<span class="nc" id="L204">    Object primaryKey = getFeaturePrimaryKeyByFid(tmFeatureType, featureId);</span>

    List&lt;AttachmentMetadata&gt; response;
    try {
<span class="nc" id="L208">      response = AttachmentsHelper.listAttachmentsForFeature(tmFeatureType, primaryKey);</span>
<span class="nc" id="L209">    } catch (IOException | SQLException e) {</span>
<span class="nc" id="L210">      throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, e.getMessage());</span>
<span class="nc" id="L211">    }</span>

<span class="nc" id="L213">    return new ResponseEntity&lt;&gt;(response, HttpStatus.OK);</span>
  }

  @DeleteMapping(
      path = &quot;${tailormap-api.base-path}/{viewerKind}/{viewerName}/layer/{appLayerId}/attachment/{attachmentId}&quot;)
  @Transactional
  public ResponseEntity&lt;Serializable&gt; deleteAttachment(
      @ModelAttribute AppTreeLayerNode appTreeLayerNode,
      @ModelAttribute GeoService service,
      @ModelAttribute GeoServiceLayer layer,
      @ModelAttribute Application application,
      @PathVariable UUID attachmentId) {
<span class="nc" id="L225">    editUtil.checkEditAuthorisation();</span>

<span class="nc" id="L227">    TMFeatureType tmFeatureType = editUtil.getEditableFeatureType(application, appTreeLayerNode, service, layer);</span>

<span class="nc" id="L229">    checkFeatureTypeSupportsAttachments(tmFeatureType);</span>

    try {
<span class="nc" id="L232">      AttachmentsHelper.deleteAttachment(attachmentId, tmFeatureType);</span>
<span class="nc" id="L233">    } catch (IOException | SQLException e) {</span>
<span class="nc" id="L234">      throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, e.getMessage());</span>
<span class="nc" id="L235">    }</span>

<span class="nc" id="L237">    return new ResponseEntity&lt;&gt;(HttpStatus.NO_CONTENT);</span>
  }

  @Transactional
  @GetMapping(
      path = &quot;${tailormap-api.base-path}/{viewerKind}/{viewerName}/layer/{appLayerId}/attachment/{attachmentId}&quot;,
      produces = {&quot;application/octet-stream&quot;})
  public ResponseEntity&lt;byte[]&gt; getAttachment(
      @ModelAttribute AppTreeLayerNode appTreeLayerNode,
      @ModelAttribute GeoService service,
      @ModelAttribute GeoServiceLayer layer,
      @ModelAttribute Application application,
      @PathVariable UUID attachmentId) {

<span class="nc" id="L251">    TMFeatureType tmFeatureType = editUtil.getEditableFeatureType(application, appTreeLayerNode, service, layer);</span>

    try {
<span class="nc" id="L254">      final AttachmentsHelper.AttachmentWithBinary attachmentWithBinary =</span>
<span class="nc" id="L255">          AttachmentsHelper.getAttachment(tmFeatureType, attachmentId);</span>

<span class="nc bnc" id="L257" title="All 2 branches missed.">      if (attachmentWithBinary == null) {</span>
<span class="nc" id="L258">        throw new ResponseStatusException(</span>
<span class="nc" id="L259">            HttpStatus.NOT_FOUND, &quot;Attachment %s not found&quot;.formatted(attachmentId.toString()));</span>
      }

      // the binary attachment() is a read-only ByteBuffer, so we cant use .array()
<span class="nc" id="L263">      final ByteBuffer bb = attachmentWithBinary.attachment().asReadOnlyBuffer();</span>
<span class="nc" id="L264">      bb.rewind();</span>
<span class="nc" id="L265">      byte[] attachmentData = new byte[bb.remaining()];</span>
<span class="nc" id="L266">      bb.get(attachmentData);</span>

<span class="nc" id="L268">      return ResponseEntity.ok()</span>
<span class="nc" id="L269">          .header(</span>
              &quot;Content-Disposition&quot;,
              &quot;inline; filename=\&quot;&quot;
<span class="nc" id="L272">                  + attachmentWithBinary.attachmentMetadata().getFileName() + &quot;\&quot;&quot;)</span>
<span class="nc" id="L273">          .contentType(MediaType.parseMediaType(</span>
<span class="nc" id="L274">              attachmentWithBinary.attachmentMetadata().getMimeType()))</span>
<span class="nc" id="L275">          .body(attachmentData);</span>
<span class="nc" id="L276">    } catch (SQLException | IOException e) {</span>
<span class="nc" id="L277">      throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, e.getMessage());</span>
    }
  }

  private Object getFeaturePrimaryKeyByFid(TMFeatureType tmFeatureType, String featureId)
      throws ResponseStatusException {
<span class="nc" id="L283">    final Filter fidFilter = ff.id(ff.featureId(featureId));</span>
<span class="nc" id="L284">    SimpleFeatureSource fs = null;</span>
    try {
<span class="nc" id="L286">      fs = featureSourceFactoryHelper.openGeoToolsFeatureSource(tmFeatureType);</span>
<span class="nc" id="L287">      Query query = new Query();</span>
<span class="nc" id="L288">      query.setFilter(fidFilter);</span>
<span class="nc" id="L289">      query.setPropertyNames(tmFeatureType.getPrimaryKeyAttribute());</span>
<span class="nc" id="L290">      try (SimpleFeatureIterator sfi = fs.getFeatures(query).features()) {</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">        if (!sfi.hasNext()) {</span>
<span class="nc" id="L292">          throw new ResponseStatusException(</span>
<span class="nc" id="L293">              HttpStatus.NOT_FOUND, &quot;Feature with id %s does not exist&quot;.formatted(featureId));</span>
        }
<span class="nc" id="L295">        return sfi.next().getAttribute(tmFeatureType.getPrimaryKeyAttribute());</span>
      }
<span class="nc" id="L297">    } catch (IOException e) {</span>
<span class="nc" id="L298">      throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, e.getMessage(), e);</span>
    } finally {
<span class="nc bnc" id="L300" title="All 2 branches missed.">      if (fs != null) {</span>
<span class="nc" id="L301">        fs.getDataStore().dispose();</span>
      }
    }
  }

  private void checkFeatureTypeSupportsAttachments(TMFeatureType tmFeatureType) throws ResponseStatusException {
<span class="nc" id="L307">    Set&lt;@Valid AttachmentAttributeType&gt; attachmentAttrSet =</span>
<span class="nc" id="L308">        tmFeatureType.getSettings().getAttachmentAttributes();</span>
<span class="nc bnc" id="L309" title="All 4 branches missed.">    if (attachmentAttrSet == null || attachmentAttrSet.isEmpty()) {</span>
<span class="nc" id="L310">      throw new ResponseStatusException(HttpStatus.BAD_REQUEST, &quot;Layer does not support attachments&quot;);</span>
    }
<span class="nc" id="L312">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>